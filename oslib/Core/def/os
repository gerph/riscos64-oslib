TITLE OS;

CONST
   OS_ErrorLimit    = .Int: 252,
   OS_FileNameLimit = .Int: 1024,
   OS_CLILimit      = .Int: 1024;

TYPE
   OS_T              = .Int "Monotonic time",
   OS_F              = .Int "File handle (32bit)",
   OS_Mode             "Mode number",
   OS_GCOL           = .Byte "Graphical colour, 6 or 8 bits",
   OS_Tint           = .Byte "Graphical tint",
   OS_Action         = .Byte "Graphical action",
   OS_Colour         = .Bits "(r, g, b) triplet, also called palette entry",
   OS_ColourNumber   = .Int "Colour number - value in screen memory",
   OS_ColourPair     = .Struct (OS_Colour: on, OS_Colour: off),
   OS_Palette        = .Struct (OS_Colour: entries ...),
   OS_SpritePalette  = .Struct (OS_ColourPair: entries ...),
   OS_ECF            = .Struct ([8] .Bits: ecf),
   OS_CorrectionTable = .Struct ([256] .Byte: gamma),
   OS_BCDDateAndTime = .Struct (.Byte: year, .Byte: month, .Byte: date,
                             .Byte: weekday, .Byte: hour, .Byte: minute,
                             .Byte: second),
   OS_StationNumber  = .Struct (.Int: station, .Int: net),
   OS_Box            = .Struct (.Int: x0, .Int: y0, .Int: x1, .Int: y1),
   OS_Factors        = .Struct (.Int: xmul, .Int: ymul, .Int: xdiv,
                             .Int: ydiv) "Scaling factors for plotting",
   OS_ChangeBox      = .Struct (.Int: state, OS_Box: box),
   OS_Error          = .Struct (.Bits: errnum, [OS_ErrorLimit] .Char: errmess),
   OS_DateAndTime    = [5] .Byte "System date and time",
   OS_Coord          = .Struct (.Int: x, .Int: y),
   OS_Trfm           = .Struct ([3] [2] .Int: entries) "Transformation matrix",
   OS_HomTrfm        = .Struct ([2] [2] .Int: entries) "Transformation
                       matrix without translation part",
   OS_Pgm            = .Struct ([4] OS_Coord: coords) "Parallelogram",
   OS_ErrorHandlerBuffer = .Struct (.Int: pc, .Bits: errnum, 
                             [248] .Char: errmess);

// Misc uses:
TYPE
   OS_ColourMap =
      .Struct
      (  
         .Ref Void: workspace,
         .Ref .Asm: function
      );

CONST
   //For the parts of an OS_Colour
   OS_RShift      = .Int: 8,
   OS_GShift      = .Int: 16,
   OS_BShift      = .Int: 24,
   OS_R           = .Bits: &FF00,
   OS_G           = .Bits: &FF0000,
   OS_B           = .Bits: &FF000000,
   OS_ColourRange = .Int: 255;

CONST
   OS_Mode1bpp90x45 = OS_Mode: 0,
   OS_Mode2bpp90x45 = OS_Mode: 8,
   OS_Mode4bpp90x45 = OS_Mode: 12,
   OS_Mode8bpp90x45 = OS_Mode: 15,
// OS_Mode1bpp45x45 doesn't exist
   OS_Mode2bpp45x45 = OS_Mode: 1,
   OS_Mode4bpp45x45 = OS_Mode: 9,
   OS_Mode8bpp45x45 = OS_Mode: 13,
   OS_Mode1bpp90x90 = OS_Mode: 25,
   OS_Mode2bpp90x90 = OS_Mode: 26,
   OS_Mode4bpp90x90 = OS_Mode: 27,
   OS_Mode8bpp90x90 = OS_Mode: 28;

CONST
   OS_Inch = .Int: 180 "1in in O S units";

CONST
   //for OS_WriteC/VDU
   OS_VDUNull              = .Char:   0,
   OS_VDUCharToPrinter     = .Char:   1,
   OS_VDUPrinterOn         = .Char:   2,
   OS_VDUPrinterOff        = .Char:   3,
   OS_VDUGraphTextOff      = .Char:   4,
   OS_VDUSplitCursors      = .Char:   4,
   OS_VDUGraphTextOn       = .Char:   5,
   OS_VDUJoinCursors       = .Char:   5,
   OS_VDUScreenOn          = .Char:   6,
   OS_VDUVduOn             = .Char:   6,
   OS_VDUBell              = .Char:   7,
   OS_VDUBackspace         = .Char:   8,
   OS_VDUTab               = .Char:   9,
   OS_VDULinefeed          = .Char:  10,
   OS_VDULineFeed          = .Char:  10,
   OS_VDUVerticalTab       = .Char:  11,
   OS_VDUClS               = .Char:  12,
   OS_VDUReturn            = .Char:  13,
   OS_VDUPageModeOn        = .Char:  14,
   OS_VDUPageModeOff       = .Char:  15,
   OS_VDUClG               = .Char:  16,
   OS_VDUSetTextColour     = .Char:  17,
   OS_VDUSetGCOL           = .Char:  18,
   OS_VDUSetPalette        = .Char:  19,
   OS_VDUResetColours      = .Char:  20,
   OS_VDUScreenOff         = .Char:  21,
   OS_VDUVduOff            = .Char:  21,
   OS_VDUMode              = .Char:  22,
   OS_VDUSetMode           = .Char:  22,
   OS_VDUMisc              = .Char:  23,
   OS_VDUSetGraphicsWindow = .Char:  24,
   OS_VDUPlot              = .Char:  25,
   OS_VDUPlotVdu           = .Char:  25,
   OS_VDUResetWindows      = .Char:  26,
   OS_VDUEscape            = .Char:  27,
   OS_VDUSetTextWindow     = .Char:  28,
   OS_VDUSetGraphicsOrigin = .Char:  29,
   OS_VDUHomeTextCursor    = .Char:  30,
   OS_VDUSetTextCursor     = .Char:  31,
   OS_VDUSpace             = .Char:  32,
   OS_VDUDelete            = .Char: 127;

CONST
   //For VDU 23
   OS_MiscInterlace         = .Char:  0,
   OS_MiscCursor            = .Char:  1,
   OS_MiscSetECF1           = .Char:  2,
   OS_MiscSetECF2           = .Char:  3,
   OS_MiscSetECF3           = .Char:  4,
   OS_MiscSetECF4           = .Char:  5,
   OS_MiscSetDotStyle       = .Char:  6,
   OS_MiscScroll            = .Char:  7,
   OS_MiscClearRegion       = .Char:  8,
   OS_MiscSetOn             = .Char:  9,
   OS_MiscSetOff            = .Char: 10,
   OS_MiscSetBBCECF         = .Char: 11,
   OS_MiscSetUnpackedECF1   = .Char: 12,
   OS_MiscSetUnpackedECF2   = .Char: 13,
   OS_MiscSetUnpackedECF3   = .Char: 14,
   OS_MiscSetUnpackedECF4   = .Char: 15,
   OS_MiscSetCursorMovement = .Char: 16,
   OS_MiscMisc              = .Char: 17;

CONST
   //For VDU 23, 17
   OS_MiscSetTextFGTint        = .Char: 0,
   OS_MiscSetTextBGTint        = .Char: 1,
   OS_MiscSetGraphicsFGTint    = .Char: 2,
   OS_MiscSetGraphicsBGTint    = .Char: 3,
   OS_MiscSetECFInterpretation = .Char: 4,
   OS_MiscInvertText           = .Char: 5,
   OS_MiscSetECFOrigin         = .Char: 6,
   OS_MiscSetCharSize          = .Char: 7;

CONST
   OS_ActionOverwrite        = OS_Action: 0,
   OS_ActionDisjoin          = OS_Action: 1,
   OS_ActionConjoin          = OS_Action: 2,
   OS_ActionExclusiveDisjoin = OS_Action: 3,
   OS_ActionInvert           = OS_Action: 4,
   OS_ActionIdentity         = OS_Action: 5,
   OS_ActionConjoinNegation  = OS_Action: 6,
   OS_ActionDisjoinNegation  = OS_Action: 7,
   OS_ActionUseMask          = OS_Action: 8,
   OS_ActionUseECF1          = OS_Action: 0x10,
   OS_ActionUseECF2          = OS_Action: 0x20,
   OS_ActionUseECF3          = OS_Action: 0x30,
   OS_ActionUseECF4          = OS_Action: 0x40,
   OS_ActionUseGiantECF      = OS_Action: 0x50;

CONST
   //for VDU driver
   OS_GCOLSetFG = OS_GCOL: 0b0,
   OS_GCOLSetBG = OS_GCOL: 0b10000000;

TYPE OS_PlotCode = .Bits;
CONST
   //For OS_Plot
   OS_PlotSolid             = OS_PlotCode: 0x00,
   OS_PlotSolidExEnd        = OS_PlotCode: 0x08,
   OS_PlotDotted            = OS_PlotCode: 0x10,
   OS_PlotDottedExEnd       = OS_PlotCode: 0x18,
   OS_PlotSolidExStart      = OS_PlotCode: 0x20,
   OS_PlotSolidExBoth       = OS_PlotCode: 0x28,
   OS_PlotDottedExStart     = OS_PlotCode: 0x30,
   OS_PlotDottedExBoth      = OS_PlotCode: 0x38,
   OS_PlotPoint             = OS_PlotCode: 0x40,
   OS_PlotHorizontalToNonBG = OS_PlotCode: 0x48,
   OS_PlotTriangle          = OS_PlotCode: 0x50,
   OS_PlotRightToBG         = OS_PlotCode: 0x58,
   OS_PlotRectangle         = OS_PlotCode: 0x60,
   OS_PlotHorizontalToFG    = OS_PlotCode: 0x68,
   OS_PlotParallelogram     = OS_PlotCode: 0x70,
   OS_PlotRightToNonFG      = OS_PlotCode: 0x78,
   OS_PlotFloodToNonBG      = OS_PlotCode: 0x80,
   OS_PlotFloodToFG         = OS_PlotCode: 0x88,
   OS_PlotCircleOutline     = OS_PlotCode: 0x90,
   OS_PlotCircle            = OS_PlotCode: 0x98,
   OS_PlotArc               = OS_PlotCode: 0xA0,
   OS_PlotSegment           = OS_PlotCode: 0xA8,
   OS_PlotSector            = OS_PlotCode: 0xB0,
   OS_PlotBlock             = OS_PlotCode: 0xB8,
   OS_PlotEllipseOutline    = OS_PlotCode: 0xC0,
   OS_PlotEllipse           = OS_PlotCode: 0xC8,

   OS_MoveBy        = OS_PlotCode: 0,
   OS_PlotBy        = OS_PlotCode: 1,
   OS_PlotInverseBy = OS_PlotCode: 2,
   OS_PlotBGBy      = OS_PlotCode: 3,
   OS_MoveTo        = OS_PlotCode: 4,
   OS_PlotTo        = OS_PlotCode: 5,
   OS_PlotInverseTo = OS_PlotCode: 6,
   OS_PlotBGTo      = OS_PlotCode: 7;

TYPE OS_VarType = .Int;
CONST
   //For OS_{Read,Set}VarVal
   OS_VartypeString        = OS_VarType: 0,
   OS_VartypeNumber        = OS_VarType: 1,
   OS_VartypeMacro         = OS_VarType: 2,
   OS_VartypeExpanded      = OS_VarType: 3,
   OS_VartypeLiteralString = OS_VarType: 4,
   OS_VartypeCode          = OS_VarType: 16;

TYPE OS_ModeVar = .Int;
CONST
   OS_ModevarModeFlags    = OS_ModeVar: 0,
   OS_ModevarRScreen      = OS_ModeVar: 1,
   OS_ModevarBScreen      = OS_ModeVar: 2,
   OS_ModevarNColour      = OS_ModeVar: 3,
   OS_ModevarXEigFactor   = OS_ModeVar: 4,
   OS_ModevarYEigFactor   = OS_ModeVar: 5,
   OS_ModevarLineLength   = OS_ModeVar: 6,
   OS_ModevarScreenSize   = OS_ModeVar: 7,
   OS_ModevarYShiftFactor = OS_ModeVar: 8,
   OS_ModevarLog2BPP      = OS_ModeVar: 9,
   OS_ModevarLog2BPC      = OS_ModeVar: 10,
   OS_ModevarXWindLimit   = OS_ModeVar: 11,
   OS_ModevarYWindLimit   = OS_ModeVar: 12;

TYPE OS_ModeFlags = .Bits;
CONST
   OS_ModeFlagNonGraphics    = OS_ModeFlags: %1,
   OS_ModeFlagTeletext       = OS_ModeFlags: %10,
   OS_ModeFlagGap            = OS_ModeFlags: %100,
   OS_ModeFlagBBCGap         = OS_ModeFlags: %1000,
   OS_ModeFlagHiResMono      = OS_ModeFlags: %10000,
   OS_ModeFlagDoubleHeight   = OS_ModeFlags: %100000,
   OS_ModeFlagHardwareScroll = OS_ModeFlags: %1000000,
   OS_ModeFlagFullPalette    = OS_ModeFlags: %10000000;

TYPE OS_VDUVar = OS_ModeVar;
CONST
   OS_VduvarGWLCol          = OS_VDUVar: 128,
   OS_VduvarGWBRow          = OS_VDUVar: 129,
   OS_VduvarGWRCol          = OS_VDUVar: 130,
   OS_VduvarGWTRow          = OS_VDUVar: 131,
   OS_VduvarTWLCol          = OS_VDUVar: 132,
   OS_VduvarTWBRow          = OS_VDUVar: 133,
   OS_VduvarTWRCol          = OS_VDUVar: 134,
   OS_VduvarTWTRow          = OS_VDUVar: 135,
   OS_VduvarOrgX            = OS_VDUVar: 136,
   OS_VduvarOrgY            = OS_VDUVar: 137,
   OS_VduvarGCsX            = OS_VDUVar: 138,
   OS_VduvarGCsY            = OS_VDUVar: 139,
   OS_VduvarOlderCsX        = OS_VDUVar: 140,
   OS_VduvarOlderCsY        = OS_VDUVar: 141,
   OS_VduvarOldCsX          = OS_VDUVar: 142,
   OS_VduvarOldCsY          = OS_VDUVar: 143,
   OS_VduvarGCsIX           = OS_VDUVar: 144,
   OS_VduvarGCsIY           = OS_VDUVar: 145,
   OS_VduvarNewPtX          = OS_VDUVar: 146,
   OS_VduvarNewPtY          = OS_VDUVar: 147,
   OS_VduvarScreenStart     = OS_VDUVar: 148,
   OS_VduvarDisplayStart    = OS_VDUVar: 149,
   OS_VduvarTotalScreenSize = OS_VDUVar: 150,
   OS_VduvarGPLFMD          = OS_VDUVar: 151,
   OS_VduvarGPLBMD          = OS_VDUVar: 152,
   OS_VduvarGFCOL           = OS_VDUVar: 153,
   OS_VduvarGBCOL           = OS_VDUVar: 154,
   OS_VduvarTForeCol        = OS_VDUVar: 155,
   OS_VduvarTBackCol        = OS_VDUVar: 156,
   OS_VduvarGFTint          = OS_VDUVar: 157,
   OS_VduvarGBTint          = OS_VDUVar: 158,
   OS_VduvarTFTint          = OS_VDUVar: 159,
   OS_VduvarTBTint          = OS_VDUVar: 160,
   OS_VduvarMaxMode         = OS_VDUVar: 161,
   OS_VduvarGCharSizeX      = OS_VDUVar: 162,
   OS_VduvarGCharSizeY      = OS_VDUVar: 163,
   OS_VduvarGCharSpaceX     = OS_VDUVar: 164,
   OS_VduvarGCharSpaceY     = OS_VDUVar: 165,
   OS_VduvarHLineAddr       = OS_VDUVar: 166,
   OS_VduvarTCharSizeX      = OS_VDUVar: 167,
   OS_VduvarTCharSizeY      = OS_VDUVar: 168,
   OS_VduvarTCharSpaceX     = OS_VDUVar: 169,
   OS_VduvarTCharSpaceY     = OS_VDUVar: 170,
   OS_VduvarGCOLOraEorAddr  = OS_VDUVar: 171,
   OS_VduvarVIDCClockSpeed  = OS_VDUVar: 172,
   OS_VduvarWindowWidth     = OS_VDUVar: 256,
   OS_VduvarWindowHeight    = OS_VDUVar: 257;

CONST
   OS_Foreground = .Bits: 0,
   OS_Background = .Bits: %10000000;

CONST
   OS_ColourTransparent   = OS_Colour: &FFFFFFFF,

   //primaries and secondaries
   OS_ColourRed           = OS_Colour: &0000FF00,
   OS_ColourGreen         = OS_Colour: &00FF0000,
   OS_ColourBlue          = OS_Colour: &FF000000,
   OS_ColourCyan          = OS_Colour: &FFFF0000,
   OS_ColourMagenta       = OS_Colour: &FF00FF00,
   OS_ColourYellow        = OS_Colour: &00FFFF00,

   //greyscale
   OS_ColourWhite         = OS_Colour: &FFFFFF00,
   OS_ColourVeryLightGrey = OS_Colour: &DDDDDD00,
   OS_ColourLightGrey     = OS_Colour: &BBBBBB00,
   OS_ColourMidLightGrey  = OS_Colour: &99999900,
   OS_ColourMidDarkGrey   = OS_Colour: &77777700,
   OS_ColourDarkGrey      = OS_Colour: &55555500,
   OS_ColourVeryDarkGrey  = OS_Colour: &33333300,
   OS_ColourBlack         = OS_Colour: &00000000,

   //WIMP colours
   OS_ColourDarkBlue      = OS_Colour: &99440000,
   OS_ColourLightYellow   = OS_Colour: &00EEEE00,
   OS_ColourLightGreen    = OS_Colour: &00CC0000,
   OS_ColourLightRed      = OS_Colour: &0000DD00,
   OS_ColourCream         = OS_Colour: &BBEEEE00,
   OS_ColourDarkGreen     = OS_Colour: &00885500,
   OS_ColourOrange        = OS_Colour: &00BBFF00,
   OS_ColourLightBlue     = OS_Colour: &FFBB0000;

TYPE OS_DeviceType = .Int;
CONST //device numbers
   OS_DevicePrinterBusy           = OS_DeviceType: 0,
   OS_DeviceSerialRinging         = OS_DeviceType: 1,
   OS_DevicePrinterAcknowledge    = OS_DeviceType: 2,
   OS_DeviceVSync                 = OS_DeviceType: 3,
   OS_DevicePowerOn               = OS_DeviceType: 4,
   OS_DeviceIOCTimer0             = OS_DeviceType: 5,
   OS_DeviceIOCTimer1             = OS_DeviceType: 6,
   OS_DeviceFIQDowngrade          = OS_DeviceType: 7,
   OS_DeviceExpansionFIQDowngrade = OS_DeviceType: 8,
   OS_DeviceSoundBuffer           = OS_DeviceType: 9,
   OS_DeviceSerialController      = OS_DeviceType: 10,
   OS_DeviceHardDiscController    = OS_DeviceType: 11,
   OS_DeviceFloppyDiscChanged     = OS_DeviceType: 12,
   OS_DeviceExpansionCard         = OS_DeviceType: 13,
   OS_DeviceKeyboardTxEmpty       = OS_DeviceType: 14,
   OS_DeviceKeyboardRxFull        = OS_DeviceType: 15;

CONST //82C71[01] device numbers
   OS_DevicePrinter         = .Int: 0 "82C71[01] device number for printer",
   OS_DeviceBatteryWarning  = .Int: 1 "82C71[01] device number for battery warning",
   OS_DeviceFloppyDiscIndex = .Int: 2 "82C71[01] device number for floppy disc",
   OS_DeviceIDEDisc         = .Int: 11 "82C71[01] device number for I D E disc";

CONST
   //Structure of an error number:
   OS_ErrorNumberShift    = .Int: 0,      //shift
   OS_ErrorNumber         = .Bits: &FF,   //mask
   OS_ErrorSourceShift    = .Int: 8,      //shift
   OS_ErrorSource         = .Bits: &FFFF00, //mask
   OS_ErrorCategoryShift  = .Int: 24,     //shift
   OS_ErrorCategory       = .Bits: &7000000,  //mask

   OS_CategoryUnclassified = .Int: 0,
   OS_CategoryInformation  = .Int: 1,
   OS_CategoryWarning      = .Int: 2,
   OS_CategorySystem       = .Int: 3;

CONST
   //Error messages in Resources.Global.Messages. THESE SHOULD BE MATCHED UP
   //PROPERLY with the error numbers they actually correspond to!!!
   OS_GlobalEscape     = .Int: 1,
   OS_GlobalFatal      = .Int: 2,
   OS_GlobalIsAFil     = .Int: 3,
   OS_GlobalIsntFil    = .Int: 4,
   OS_GlobalIsADir     = .Int: 5,
   OS_GlobalIsntDir    = .Int: 6,
   OS_GlobalNoFile     = .Int: 7,
   OS_GlobalNoDir      = .Int: 8,
   OS_GlobalNoAny      = .Int: 9,
   OS_GlobalTypsBad    = .Int: 10,
   OS_GlobalBadRen     = .Int: 11,
   OS_GlobalBadAcc     = .Int: 12,
   OS_GlobalOpnFils    = .Int: 13,
   OS_GlobalBadName    = .Int: 14,
   OS_GlobalLongNam    = .Int: 15,
   OS_GlobalChannel    = .Int: 16,
   OS_GlobalBadSWI     = .Int: 17,
   OS_GlobalModInUs    = .Int: 18,
   OS_GlobalStrOFlo    = .Int: 19,
   OS_GlobalNumOFlo    = .Int: 20,
   OS_GlobalBufOFlo    = .Int: 21,
   OS_GlobalBadStn     = .Int: 22,
   OS_GlobalBadNet     = .Int: 23,
   OS_GlobalFullNet    = .Int: 24,
   OS_GlobalNoEco      = .Int: 25,
   OS_GlobalBadRead    = .Int: 26,
   OS_GlobalBadWrt     = .Int: 27,
   OS_GlobalDataLst    = .Int: 28,
   OS_GlobalBadFSOp    = .Int: 29,
   OS_GlobalFSNoRd     = .Int: 30,
   OS_GlobalFSNoWrt    = .Int: 31,
   OS_GlobalFSInUse    = .Int: 32,
   OS_GlobalBadAddress = .Int: 33,
   OS_GlobalNoStore    = .Int: 34,
   OS_GlobalRAMLoadC   = .Int: 35,
   OS_GlobalDDS0       = .Int: 36,
   OS_GlobalDDS1       = .Int: 37,
   OS_GlobalDDS2       = .Int: 38,
   OS_GlobalDDS3       = .Int: 39,
   OS_GlobalCSDS       = .Int: 40,
   OS_GlobalLDS        = .Int: 41,
   OS_GlobalURDS       = .Int: 42,
   OS_GlobalDr         = .Int: 43,
   OS_GlobalApp        = .Int: 44,
   OS_GlobalExDt       = .Int: 45,
   OS_GlobalExLdEx     = .Int: 46,
   OS_GlobalUseDesk    = .Int: 47,
   OS_GlobalAppQuit    = .Int: 48,
   OS_GlobalNoMem      = .Int: 49,
   OS_GlobalBadHard    = .Int: 50,
   OS_GlobalBadParm    = .Int: 51,
   OS_GlobalNoWimp     = .Int: 52;

CONST
   //General OS errors
   Error_Escape = .Bits: 17,
   Error_BadMode = .Bits: 25,
   Error_IsADir = .Bits: 168,
   Error_TypesDontMatch = .Bits: 175,
   Error_BadRename = .Bits: 176,
   Error_BadCopy = .Bits: 177,
   Error_OutsideFile = .Bits: 183,
   Error_AccessViolation = .Bits: 189,
   Error_TooManyOpenFiles = .Bits: 192,
   Error_NotOpenForUpdate = .Bits: 193,
   Error_FileOpen = .Bits: 194,
   Error_ObjectLocked = .Bits: 195,
   Error_AlreadyExists = .Bits: 196,
   Error_BadFileName = .Bits: 204,
   Error_FileNotFound = .Bits: 214,
   Error_Syntax = .Bits: 220,
   Error_BadNoParms = .Bits: 220,
   Error_TooManyParms = .Bits: 220,
   Error_Channel = .Bits: 222,
   Error_EndOfFile = .Bits: 223,
   Error_BadFilingSystemName = .Bits: 248,
   Error_UnknownFilingSystem = .Bits: 248,
   Error_BadKey = .Bits: 251,
   Error_BadAddress = .Bits: 252,
   Error_BadString = .Bits: 253,
   Error_BadAliasString = .Bits: 253,
   Error_BadParmString = .Bits: 253,
   Error_WildCards = .Bits: 253, //Unfortunate clash
   Error_BadCommand = .Bits: 254,

   //Variables errors
   Error_BadMacVal = .Bits: &120,
   Error_BadVarNam = .Bits: &121,
   Error_BadVarType = .Bits: &122,
   Error_VarNoRoom = .Bits: &123,
   Error_VarCantFind = .Bits: &124,
   Error_VarTooLong = .Bits: &125,

   //General OS errors
   Error_RedirectFail = .Bits: &140,
   Error_StackFull = .Bits: &141,

   //Expression errors
   Error_BadHex = .Bits: &160,
   Error_BadExpr = .Bits: &161,
   Error_BadBra = .Bits: &162,
   Error_StkOFlo = .Bits: &163,
   Error_MissOpn = .Bits: &164,
   Error_MissOpr = .Bits: &165,
   Error_BadBits = .Bits: &166,
   Error_StrOFlo = .Bits: &167,
   Error_BadItm = .Bits: &168,
   Error_DivZero = .Bits: &169,
   Error_BadBase = .Bits: &16A,
   Error_BadNumb = .Bits: &16B,
   Error_NumbTooBig = .Bits: &16C,

   //Vector claim/release errors,
   Error_BadClaimNum = .Bits: &1A1,
   Error_BadRelease = .Bits: &1A2,
   Error_BadDevNo = .Bits: &1A3,
   Error_BadDevVecRel = .Bits: &1A4,

   //Environment alteration SWI errors
   Error_BadEnvNumber = .Bits: &1B0,
   Error_CantCancelQuit = .Bits: &1B1,

   //Change dynamic area errors
   Error_ChDynamCAO = .Bits: &1C0,
   Error_ChDynamNotAllMoved = .Bits: &1C1,
   Error_AplWSpaceInUse = .Bits: &1C2,
   Error_RAMFsUnchangeable = .Bits: &1C3,

   //OS_CLI and other errors
   Error_OSCLILongLine = .Bits: &1E0 "line too long for OS_CLI",
   Error_OSCLITooHard = .Bits: &1E1 "OS_CLI ran out of buffers",
   Error_RCExc = .Bits: &1E2,
   Error_RCNegative = .Bits: &1E2,
   Error_SysHeapFull = .Bits: &1E3,
   Error_BuffOverflow = .Bits: &1E4,
   Error_BadTime = .Bits: &1E5,
   Error_NoSuchSWI = .Bits: &1E6,
   Error_Unimplemented = .Bits: &1E7,
   Error_OutOfRange = .Bits: &1E8,
   Error_NoOSCLISpecials = .Bits: &1E9,
   Error_BadParameters = .Bits: &1EA,
   Error_ArgRepeated = .Bits: &1EB,
   Error_BadReadSysInfo = .Bits: &1EC,

   //Convert date and time errors
   Error_CDATStackOverflow = .Bits: &2C0,
   Error_CDATBufferOverflow = .Bits: &2C1,
   Error_CDATBadField = .Bits: &2C2,

   Error_CantStartApplication = .Bits: &600 "Unable to start application",
   Error_BadCommandOption     = .Bits: &601 "Bad command option",
   Error_UnknownSerialOp      = .Bits: &602 "Unknown serial operation",
   Error_BadHard              = .Bits: &603 "Unsupported hardware configuration";

SWI
   //A few simple ones to start with ...
   OS_WriteC = (NUMBER 0 "Writes a character to all of the active output
         streams", ENTRY (R0 = .Char: c)),
   WrchV = (NUMBER 0x34, ENTRY (R0 = .Char: c, R9 # &03 "OS_WriteC vector")),
   OS_WriteS = (NUMBER 1 "Writes the following string to all of the
         active output streams - cannot be called via APCS", ABSENT),
   OS_Write0 = (NUMBER 2 "Writes a string to all of the active output
         streams", ENTRY (R0 -> .String: s), EXIT (R0?)),
   OS_NewLine = (NUMBER 3 "Writes a line feed followed by a carriage
         return to all of the active output streams"),
   OS_ReadC = (NUMBER 4 "Reads a character from the input stream",
         EXIT (R0 = .Char: c, FLAGS!)),
   RdchV = (NUMBER 0x34, ENTRY (R9 # &04 "OS_ReadC vector"),
        EXIT (R0 = .Char: c, FLAGS!)),
   OS_CLI = (NUMBER 5 "Processes a supervisor command",
         ENTRY (R0 -> .String: command)),
   CLIV = (NUMBER 0x34, ENTRY (R0 -> .String: command, R9 # &05
         "OS_CLI vector"));

SWI OS_ReadLine =
   (  NUMBER 0xE "Reads a line from the input stream",
      ENTRY
      (  R0 = .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_ReadLineGivenEcho =
   (  NUMBER 0xE "Reads a line from the input stream, using the given echo 
            character",
      ENTRY
      (  R0 # &40000000,
         R0 | .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char,
         R4 = .Char: echo
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_ReadLineSuppressInvalid =
   (  NUMBER 0xE "Reads a line from the input stream, not echoing invalid 
            characters",
      ENTRY
      (  R0 # &80000000,
         R0 | .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_ReadLineGivenEchoSuppressInvalid =
   (  NUMBER 0xE "Reads a line from the input stream, using the given echo 
            character and not echoing invalid characters",
      ENTRY
      (  R0 # &C0000000,
         R0 | .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char,
         R4 = .Char: echo
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI
   ReadLineV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char,
         R4 = .Char: echo,
         R9 # &0E "OS_ReadLine vector"
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_Control =
   (  NUMBER 0xF "Reads/writes handler addresses (prefer OS_ChangeEnvironment)",
      ENTRY
      (  R0 -> .Asm: error_handler,
         R1 = .Ref OS_Error: error_buffer,
         R2 -> .Asm: escape_handler,
         R3 -> .Asm: event_handler
      ),
      EXIT
      (  R0 -> .Asm: old_error_handler,
         R1 = .Ref OS_Error: old_error_buffer,
         R2 -> .Asm: old_escape_handler,
         R3 -> .Asm: old_event_handler
   )  );

SWI OS_GetEnv =
   (  NUMBER 0x10 "Reads environment parameters",
      EXIT
      (  R0! -> .String: command,
         R1 = .Ref .Data: ram_limit,
         R2 -> OS_DateAndTime: start
   )  );

SWI OS_Exit =
   (  NUMBER 0x11 "Passes control to the most recent exit handler",
      ENTRY
      (  R0 -> OS_Error: error,
         R1 # 'ABEX',
         R2 = .Int: rc
   )  );

SWI OS_SetEnv =
   (  NUMBER 0x12 "Sets environment parameters (prefer OS_ChangeEnvironment)",
      ENTRY
      (  R0 -> .Asm: exit_handler,
         R1 = .Ref .Data: ram_limit,
         R4 -> .Asm: undefined_instruction_handler,
         R5 -> .Asm: prefetch_abort_handler,
         R6 -> .Asm: data_abort_handler,
         R7 -> .Asm: address_exception_handler
      ),
      EXIT
      (  R0 -> .Asm: old_exit_handler,
         R1 = .Ref .Data: old_ram_limit,
         R4 -> .Asm: old_undefined_instruction_handler,
         R5 -> .Asm: old_prefetch_abort_handler,
         R6 -> .Asm: old_data_abort_handler,
         R7 -> .Asm: old_address_exception_handler
   )  );

SWI OS_IntOn = (NUMBER 0x13 "Enables interrupts - cannot be called via APCS",
      ABSENT);

SWI OS_IntOff = (NUMBER 0x14 "Disables interrupts - cannot be called via APCS",
      ABSENT);

SWI
   IrqV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &02 "Called when an unknown IRQ is detected"
   )  );

TYPE OS_RegisterBlock = .Struct ([16] .Int: registers);

SWI OS_CallBack =
   (  NUMBER 0x15 "Sets up the callback handler (prefer OS_ChangeEnvironment)",
      ENTRY
      (  R0 -> OS_RegisterBlock: register_block,
         R1 -> .Asm: call_back_handler
      ),
      EXIT
      (  R0 -> OS_RegisterBlock: old_register_block,
         R1 -> .Asm: old_call_back_handler
   )  );

SWI OS_EnterOS = (NUMBER 0x16 "Sets the processor to SVC mode - cannot be
      called via APCS", ABSENT);

SWI OS_LeaveOS =
   (  NUMBER 0x7C "Sets the processor to USR mode - cannot be called via APCS",
      ABSENT
   );

SWI OS_BreakPt = (NUMBER 0x17 "Causes a break point trap to occur and
      the break point handler to be entered");

SWI OS_BreakCtrl =
   (  NUMBER 0x18 "Sets up the break point handler (prefer 
            OS_ChangeEnvironment)",
      ENTRY
      (  R0 = .Ref OS_RegisterBlock: register_block,
         R1 -> .Asm: break_pt_handler
      ),
      EXIT
      (  R0 = .Ref OS_RegisterBlock: old_register_block,
         R1 -> .Asm: old_break_pt_handler
   )  );

SWI OS_UnusedSWI =
   (  NUMBER 0x19 "Sets up the handler for unused SWI's (prefer 
            OS_ChangeEnvironment)",
      ENTRY (R0 -> .Asm: unused_swi_handler),
      EXIT  (R0! -> .Asm: old_unused_swi_handler)
   );

SWI UKSWIV = (NUMBER 0x34, ENTRY (R9 # &18 "Called when an unknown SWI
      instruction is issued - cannot be called via APCS"), ABSENT);

SWI OS_UpdateMEMC =
   (  NUMBER 0x1A "Reads or alters the contents of the MEMC control
            register",
      ENTRY
      (  R0 = .Bits: value,
         R1 = .Bits: mask
      ),
      EXIT
      (  R0! = .Bits: old_value,
         R1?
   )  );

SWI OS_SetCallBack = (NUMBER 0x1B "Causes a call to the callback handler");

SWI OS_Mouse =
   (  NUMBER 0x1C "Reads a mouse state from the buffer",
      EXIT
      (  R0 = .Int: x,
         R1 = .Int: y,
         R2 = .Bits: buttons,
         R3 = OS_T: t
   )  );

SWI
   MouseV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &1A "OS_Mouse vector"
      ),
      EXIT
      (  R0 = .Int: x,
         R1 = .Int: y,
         R2 = .Bits: buttons,
         R3 = OS_T: t
   )  );

SWI OS_Claim =
   (  NUMBER 0x1F "Adds a routine to the list of those that claim a
            vector",
      ENTRY
      (  R0 = .Int: vector,
         R1 -> .Asm: routine,
         R2 = .Ref .Data: handle //should be int, like other handles
      )
   );

SWI OS_Release =
   (  NUMBER 0x20 "Removes a routine from the list of those that claim a
            vector",
      ENTRY
      (  R0 = .Int: vector,
         R1 -> .Asm: routine,
         R2 = .Ref .Data: handle //should be int, like other handles
      )
   );

TYPE OS_ReadUnsignedFlags = .Bits;
CONST
   OS_ReadControlTerminated = OS_ReadUnsignedFlags: %10000000000000000000000000000000,
   OS_ReadByte              = OS_ReadUnsignedFlags: %1000000000000000000000000000000,
   OS_ReadLimited           = OS_ReadUnsignedFlags: %100000000000000000000000000000;

SWI OS_ReadUnsigned =
   (  NUMBER 0x21 "Converts a string to an unsigned number",
      ENTRY
      (  R0 = OS_ReadUnsignedFlags: flags,
         R1 -> .String: number,
         R2 = .Int: limit
      ),
      EXIT
      (  R1 -> .Char: end,
         R2! = .Int: value
   )  );

SWI OS_GenerateEvent = (NUMBER 0x22 "Generates an event - see individual
      reason codes", ABSENT);

SWI EventV = (NUMBER 0x34, ENTRY (R9 # &10 "OS_GenerateEvent vector -
      reason codes as OS_GenerateEvent"), ABSENT);

SWI OS_ReadVarVal =
   (  NUMBER 0x23 "Reads a variable value",
      ENTRY
      (  R0 -> .String: var,
         R1 = .Ref .String: value,
         R2 = .Int: size,
         R3 = .Int: context,
         R4 = OS_VarType: var_type
      ),
      EXIT
      (  R0?,
         R2 = .Int: used,
         R3! = .Int: context_out,
         R4 = OS_VarType: var_type_out
   )  );

CONST OS_DestroyVar = .Int: -1 "for use as 'size' in OS_SetVarVal";

SWI OS_SetVarVal =
   (  NUMBER 0x24 "Writes a variable value",
      ENTRY
      (  R0 -> .String: var,
         R1 -> .Data: value,
         R2 = .Int: size,
         R3 = .Int: context,
         R4 = OS_VarType: var_type
      ),
      EXIT
      (  R3! = .Int: context_out,
         R4 = OS_VarType: var_type_out
   )  );

TYPE OS_GSFlags = .Bits;
CONST
   OS_GSTerminateOnSpace  = OS_GSFlags: 0b100000000000000000000000000000,
   OS_GSRetainStick       = OS_GSFlags: 0b1000000000000000000000000000000,
   OS_GSRetainDoubleQuote = OS_GSFlags: 0b10000000000000000000000000000000;

SWI OS_GSInit =
   (  NUMBER 0x25 "Initialises context for use by OS_GSRead",
      ENTRY
      (  R0 -> .String: s,
         R2 = OS_GSFlags: flags
      ),
      EXIT
      (  R0 = .Int: context1,
         R1?,
         R2 = .Int: context2
   )  );

SWI OS_GSRead =
   (  NUMBER 0x26 "Returns a character from a string which has been
            initialised by OS_GSInit",
      ENTRY
      (  R0 = .Int: context1,
         R2 = .Int: context2
      ),
      EXIT
      (  R0 = .Int: context1_out,
         R1 = .Char: c,
         R2 = .Int: context2_out,
         FLAGS!
   )  );

SWI OS_GSTrans =
   (  NUMBER 0x27 "Equivalent to a call to OS_GSInit and repeated calls
            to OS_GSRead",
      ENTRY
      (  R0 -> .String: s,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1?,
         R2 = .Int: used,
         FLAGS!
      )
   );

SWI OS_BinaryToDecimal =
   (  NUMBER 0x28 "Converts a signed number to a string",
      ENTRY
      (  R0 = .Int: i,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R2! = .Int: used
   )  );

TYPE OS_DynamicAreaNo = .Int;
CONST
   OS_DynamicAreaApplicationSpace = OS_DynamicAreaNo: -1 "RISC O S 3.5+", //RO3.5
   OS_DynamicAreaSystemHeap       = OS_DynamicAreaNo: 0,
   OS_DynamicAreaRMA              = OS_DynamicAreaNo: 1,
   OS_DynamicAreaScreenMemory     = OS_DynamicAreaNo: 2,
   OS_DynamicAreaSystemSprites    = OS_DynamicAreaNo: 3,
   OS_DynamicAreaFontCache        = OS_DynamicAreaNo: 4,
   OS_DynamicAreaRAMDisc          = OS_DynamicAreaNo: 5,
   OS_DynamicAreaFreePool         = OS_DynamicAreaNo: 6 "RISC O S 3.5+"; //RO3.5

SWI OS_ChangeDynamicArea =
   (  NUMBER 0x2A "Alters the space allocation of a dynamic area",
      ENTRY
      (  R0 = OS_DynamicAreaNo: area_type,
         R1 = .Int: change
      ),
      EXIT
      (  R1! = .Int: change_out
   )  );

SWI OS_GenerateError =
   (  NUMBER 0x2B "Generates an error and invokes the error handler",
      ENTRY (R0 -> OS_Error: error)
   );

SWI
   ErrorV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &01 "OS_GenerateError vector"
   )  );

SWI OS_ReadEscapeState = (NUMBER 0x2C "Checks whether an escape condition
      has occurred", EXIT (FLAGS!));

SWI OS_EvaluateExpression =
   (  NUMBER 0x2D "Evaluates a string expression and returns an integer or
            string result",
      ENTRY
      (  R0 -> .String: expr,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R1! = .Bool: expr_is_str,
         R2 = .Int: int_value_or_str_used
   )  );

SWI OS_ReadPalette =
   (  NUMBER 0x2F "Reads the palette setting of a colour",
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type
      ),
      EXIT
      (  R2 = OS_Colour: on,
         R3 = OS_Colour: off
   )  );

SWI PaletteV = (NUMBER 0x34, ENTRY (R9 # &23 "Called whenever the
      palette is to be read or written -
      see individual reason codes"), ABSENT),

   PaletteV_ReadEntry =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type,
         R4 # 1 "Reads the palette",
         R9 # &23
      ),
      EXIT
      (  R2 = OS_Colour: on,
         R3 = OS_Colour: off,
         R4! = .Bool: incomplete
   )  ),

   PaletteV_SetEntry =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type,
         R2 = OS_Colour: on,
         R3 = OS_Colour: off,
         R4 # 2 "Sets the palette",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetOn =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 3 "Sets the flash state to on",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetOff =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 4 "Sets the flash state to off",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_Default =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 5 "Sets the palette to the default",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_ReadEntries =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_ColourNumber: entry_list,
         R1 = .Bits: colour_type_and_entry_count,
         R2 = .Ref OS_Palette: on,
         R3 = .Ref OS_Palette: off,
         R4 # 7 "Reads palette entries",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_WriteEntries =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_ColourNumber: entry_list,
         R1 = .Bits: colour_type_and_entry_count,
         R2 -> OS_Palette: palette,
         R4 # 8 "Writes palette entries",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetGammaCorrections =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_CorrectionTable: red_table,
         R1 -> OS_CorrectionTable: green_table,
         R2 -> OS_CorrectionTable: blue_table,
         R4 # 9 "Sets the gamma correction tables"
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  );

SWI OS_ServiceCall = (NUMBER 0x30 "Issues a service call -
      see individual reason codes", ABSENT);

TYPE OS_VDUVarList = .Struct (OS_VDUVar: var ...);

SWI OS_ReadVduVariables =
   (  NUMBER 0x31 "Reads a series of VDU variables",
      ENTRY
      (  R0 -> OS_VDUVarList: var_list,
         R1 = .Ref .Int: value_list
   )  );

SWI OS_ReadPoint =
   (  NUMBER 0x32 "Reads the colour of a point",
      ENTRY
      (  R0 = .Int: x,
         R1 = .Int: y
      ),
      EXIT
      (  R2 = OS_GCOL: gcol,
         R3 = OS_Tint: tint,
         R4! = .Bool: off_screen
   )  );

SWI OS_UpCall = (NUMBER 0x33 "Calls up from RISC OS to an application to
      warn of particular situations -
      see individual reason codes", ABSENT);

SWI UpCallV = (NUMBER 0x34,  ENTRY (R9 # &1D "OS_UpCall vector - reason
      codes as OS_UpCall"), ABSENT);

SWI OS_CallAVector = (NUMBER 0x34 "Calls a vector directly -
      see individual reason codes", ABSENT);

SWI OS_ReadModeVariable =
   (  NUMBER 0x35 "Reads information about a screen mode",
      ENTRY
      (  R0 = OS_Mode: mode,
         R1 = OS_ModeVar: var
      ),
      EXIT
      (  R2 = .Int: var_val,
         FLAGS!
   )  );

SWI OS_RemoveCursors = (NUMBER 0x36 "Removes the cursors from the screen");

SWI OS_RestoreCursors = (NUMBER 0x37 "Restores the cursors to the screen");

SWI OS_SWINumberToString =
   (  NUMBER 0x38 "Converts a SWI number to a string containing its name",
      ENTRY
      (  R0 = .Int: swi,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R2! = .Int: used
   )  );

SWI OS_SWINumberFromString =
   (  NUMBER 0x39 "Converts a string to a SWI number if valid",
      ENTRY (R1 -> .String: swi_name),
      EXIT  (R0! = .Int: swi)
   );

SWI OS_ValidateAddress =
   (  NUMBER 0x3A "Checks that a range of address are in logical RAM",
      ENTRY
      (  R0 = .Ref .Data: min,
         R1 = .Ref .Data: max
      ),
      EXIT (FLAGS!)
   );

SWI OS_CallAfter =
   (  NUMBER 0x3B "Calls a specified address after a delay",
      ENTRY
      (  R0 = .Int: delay,
         R1 -> .Asm: code,
         R2 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_CallEvery =
   (  NUMBER 0x3C "Calls a specified address every time a delay elapses",
      ENTRY
      (  R0 = .Int: delay,
         R1 -> .Asm: code,
         R2 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_RemoveTickerEvent =
   (  NUMBER 0x3D "Removes a given call address and handle value from the
            ticker event list",
      ENTRY
      (  R0 -> .Asm: code,
         R1 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI
   TickerV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &1C "Called every centisecond"
   )  );

TYPE OS_KeyHandler = .Struct (.Byte: k ...);

SWI OS_InstallKeyHandler =
   (  NUMBER 0x3E "Installs a key handler or reads the address of the
            current one",
      ENTRY (R0 -> OS_KeyHandler: key_handler),
      EXIT  (R0! -> OS_KeyHandler: old_key_handler)
   );

TYPE KeyV_Type = .Int;
CONST
   KeyV_TypeArchimedes = KeyV_Type: 1,
   KeyV_TypePCAT       = KeyV_Type: 2;

SWI KeyV = (NUMBER 0x34, ENTRY (R9 # &13 "Used to communicate between the kernel
      and a keyboard device driver -
      see individual reason codes"), ABSENT),

   KeyV_Present = (NUMBER 0x34, ENTRY (R0 # 0 "The given keyboard is present",
         R1 = KeyV_Type: keyboard_type, R9 # &13)),

   KeyV_TransitionUp = (NUMBER 0x34,  ENTRY (R0 # 1 "Key released",
         R1 = .Int: key, R9 # &13)),

   KeyV_TransitionDown = (NUMBER 0x34,  ENTRY (R0 # 2 "Key pressed",
         R1 = .Int: key, R9 # &13)),

   KeyV_LEDState = (NUMBER 0x34,  ENTRY (R0 # 3 "Notifies driver of LED state",
         R1 = .Bits: flags, R9 # &13)),

   KeyV_EnableDrivers = (NUMBER 0x34,  ENTRY (R0 # 4 "Enables keyboard device
         drivers", R9 # &13));

CONST
   OS_CurrentMode            = OS_Mode: -1,
   OS_NonexistentMode        = .Int: -1,
   OS_NotEnoughMemoryForMode = .Int: -2,
   OS_NoAlternativeMode      = OS_Mode: -2;

SWI OS_CheckModeValid =
   (  NUMBER 0x3F "Checks if it is possible to change into a specified mode",
      ENTRY
      (  R0 = OS_Mode: mode
      ),
      EXIT
      (  R0 = .Int: mode_status,
         R1 = OS_Mode: alternative_mode,
         FLAGS!
   )  );

TYPE OS_HandlerType = .Int;
CONST
   OS_HandlerMemoryLimit          = OS_HandlerType:  0,
   OS_HandlerUndefinedInstruction = OS_HandlerType:  1,
   OS_HandlerPrefetchAbort        = OS_HandlerType:  2,
   OS_HandlerDataAbort            = OS_HandlerType:  3,
   OS_HandlerAddressException     = OS_HandlerType:  4,
   OS_HandlerOtherExceptions      = OS_HandlerType:  5,
   OS_HandlerError                = OS_HandlerType:  6,
   OS_HandlerCallBack             = OS_HandlerType:  7,
   OS_HandlerBreakPt              = OS_HandlerType:  8,
   OS_HandlerEscape               = OS_HandlerType:  9,
   OS_HandlerEvent                = OS_HandlerType: 10,
   OS_HandlerExit                 = OS_HandlerType: 11,
   OS_HandlerUnusedSWI            = OS_HandlerType: 12,
   OS_HandlerExceptionRegisters   = OS_HandlerType: 13,
   OS_HandlerApplicationSpace     = OS_HandlerType: 14,
   OS_HandlerCAO                  = OS_HandlerType: 15,
   OS_HandlerUpCall               = OS_HandlerType: 16;

SWI OS_ChangeEnvironment =
   (  NUMBER 0x40 "Installs a handler",
      ENTRY
      (  R0 = OS_HandlerType: handler_type,
         R1 -> .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer
      ),
      EXIT
      (  R1! -> .Asm: old_handler,
         R2 = .Ref .Data: old_handle, //should be int, like other handles
         R3 = .Ref .Data: old_buffer
   )  );

SWI
   ChangeEnvironmentV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_HandlerType: handler_type,
         R1 -> .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer,
         R9 # &1E "OS_ChangeEnvironment vector"
      ),
      EXIT
      (  R1! -> .Asm: old_handler,
         R2 = .Ref .Data: old_handle, //should be int, like other handles
         R3 = .Ref .Data: old_buffer
   )  );

SWI
   OS_ClaimScreenMemory = (NUMBER 0x41 "Uses spare screen memory -
      see individual reason codes", ABSENT),
   OSClaimScreenMemory_Alloc =
   (  NUMBER 0x41,
      ENTRY
      (  R0 # 1 "Claims spare screen memory",
         R1 = .Int: size
      ),
      EXIT
      (  R1 = .Int: size_out,
         R2 = .Ref Void: blk,
         FLAGS!
   )  ),
   OSClaimScreenMemory_Free =
   (  NUMBER 0x41,
      ENTRY (R0 # 0 "Releases spare screen memory")
   );

SWI OS_ReadMonotonicTime =
   (  NUMBER 0x42 "Returns the number of centiseconds since the last hard
            reset",
      EXIT (R0! = OS_T: t)
   );

SWI OS_SubstituteArgs =
   (  NUMBER 0x43 "Substitutes command line arguments",
      ENTRY
      (  R0 -> .String: args,
         R1 = .Ref .String: buffer,
         R2 = .Int: size,
         R3 -> .String: source,
         R4 = .Int: source_size
      ),
      EXIT
      (  R2! = .Int: used
   )  );

SWI OS_PrettyPrint =
   (  NUMBER 0x44 "Writes a string with some formatting to all of the
            active output streams",
      ENTRY
      (  R0 -> .String: string,
         R1 -> .Data: dictionary,
         R2 -> .String: special
   )  );

SWI OS_Plot =
   (  NUMBER 0x45 "Direct VDU call to general plot command",
      ENTRY
      (  R0 = OS_PlotCode: plot_code,
         R1 = .Int: x,
         R2 = .Int: y
   )  );

SWI
   UKPLOTV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_PlotCode: plot_code,
         R9 # &19 "Called when an unknown OS_Plot command is issued"
   )  );

SWI OS_WriteN =
   (  NUMBER 0x46 "Writes a counted string to all of the active output
         streams",
      ENTRY
      (  R0 -> .String: s,
         R1 = .Int: size
   )  );

SWI OS_AddToVector =
   (  NUMBER 0x47 "Adds a routine to the list of those that claim a
            vector",
      ENTRY
      (  R0 = .Int: vector,
         R1 -> .Asm: routine,
         R2 = .Ref .Data: handle //should be int, like other handles
      )
   );

SWI OS_WriteEnv =
   (  NUMBER 0x48 "Sets the program environment command string and start
            time",
      ENTRY
      (  R0 -> .String: command,
         R1 -> OS_DateAndTime: start
   )  );

//   To use OS_ReadArgs, declare a structure for the output to match the
//argument string. If the argument string is
//
//      "a1/k1,...,aN/kN"
//
//declare an object of type
//
//      .Struct (T1: a1, ..., TN: aN, [BIG] .Byte: buffer)
//
//where Ti is derived from ki as follows:
//
//      /s    .Bool
//      /e    .Ref OS_GI
//      /g    .Ref OS_GS
//      other .Ref .String
//
//The value of BIG should be chosen so that all the arguments fit in the
//buffer. A pointer to the whole structure is passed in R2, and its size
//in R3.

TYPE OS_GI = .Struct (.Byte: type, [4] .Byte: i) "Type to which the
      output from a /e directive points after OS_ReadArgs";

TYPE OS_GS = .Struct (.Short: size, .Char: s ...) "Type to which the
      output from a /g directive points after OS_ReadArgs";

SWI OS_ReadArgs =
   (  NUMBER 0x49 "Given a keyword definition, scans a command string",
      ENTRY
      (  R0 -> .String: keywords,
         R1 -> .String: input,
         R2 = .Ref .String: buffer,
         R3 = .Int: size
      ),
      EXIT (R3! = .Int: spare)
   );

SWI OS_ReadRAMFsLimits =
   (  NUMBER 0x4A "Gets the current limits of the RM filing system",
      EXIT
      (  R0 -> .Data: start,
         R1 -> .Char: end
   )  );

SWI OS_ClaimDeviceVector =
   (  NUMBER 0x4B "Claims a device vector",
      ENTRY
      (  R0 = OS_DeviceType: device,
         R1 -> .Asm: driver,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Int: status,
         R4 = .Bits: mask
      )
   );

SWI OS_ReleaseDeviceVector =
   (  NUMBER 0x4C "Releases a device vector",
      ENTRY
      (  R0 = OS_DeviceType: device,
         R1 -> .Asm: driver,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Int: status,
         R4 = .Bits: mask
      )
   );

SWI OS_DelinkApplication =
   (  NUMBER 0x4D "Removes any vectors that an application is using",
      ENTRY
      (  R0 = .Ref .Data: vector_details,
         R1 = .Int: size
      ),
      EXIT
      (  R1! = .Int: used
   )  );

SWI OS_RelinkApplication =
   (  NUMBER 0x4E "Restores from a buffer any vectors that an application
            is using",
      ENTRY (R0 -> .Data: vector_details)
   );

//Types of sort (pass in R2)
TYPE OS_SortType = .Ref .Asm;
CONST
   OS_SortCardinal        = OS_SortType: 0,
   OS_SortInteger         = OS_SortType: 1,
   OS_SortCardinalPointer = OS_SortType: 2,
   OS_SortIntegerPointer  = OS_SortType: 3,
   OS_SortCIString        = OS_SortType: 4,
   OS_SortString          = OS_SortType: 5;

//Flags for OS_HeapSort (set in R1!)
CONST
   OS_SortGivenWorkspace = .Bits: 0b100000000000000000000000000000,
   OS_SortBuildArray     = .Bits: 0b1000000000000000000000000000000,
   OS_SortObjects        = .Bits: 0b10000000000000000000000000000000;

SWI OS_HeapSort =
   (  NUMBER 0x4F "Heap-sorts a list of objects",
      ENTRY
      (  R0 = .Int: count,
         R1 = .Ref .Int: array,
         R2 = OS_SortType: compare_fn,
         R3 = .Ref .Data: handle, //should be int, like other handles
         R4 = .Ref .Data: objects,
         R5 = .Int: object_size,
         R6 = .Ref Void: workspace
   )  );

SWI OS_ExitAndDie =
   (  NUMBER 0x50 "Kills a module and passes control to the most recent
            exit handler",
      ENTRY
      (  R0 -> OS_Error: error,
         R1 # 'ABEX',
         R2 = .Int: rc,
         R3 -> .String: module_name
   )  );

SWI OS_ReadMemMapInfo =
   (  NUMBER 0x51 "Reads the page size and count",
      EXIT
      (  R0 = .Int: page_size,
         R1 = .Int: page_count
   )  );

TYPE OS_AreaFlags = .Bits;
CONST
   OS_AreaAccessReadWrite = OS_AreaFlags: 0,
   OS_AreaAccessReadOnly  = OS_AreaFlags: 1,
   OS_AreaAccessNone      = OS_AreaFlags: 3,
   OS_AreaAccessShift     = .Int: 0,
   OS_AreaNotBufferable   = OS_AreaFlags: 0x00010,
   OS_AreaNotCacheable    = OS_AreaFlags: 0x00020,
   OS_AreaDoublyMapped    = OS_AreaFlags: 0x00040,
   OS_AreaNoUserDrag      = OS_AreaFlags: 0x00080,
   OS_AreaNeedsGivenPages = OS_AreaFlags: 0x00100,
   OS_AreaShrinkable      = OS_AreaFlags: 0x00200,
   OS_AreaSparse          = OS_AreaFlags: 0x00400,
   OS_AreaPrivate         = OS_AreaFlags: 0x00800,
   OS_AreaDMA             = OS_AreaFlags: 0x01000 "RISC OS 6",
   OS_AreaLocked          = OS_AreaFlags: 0x02000 "RISC OS 6",
   OS_AreaIsHeap          = OS_AreaFlags: 0x04000 "RISC OS Select",
   OS_AreaPhysical        = OS_AreaFlags: 0x08000 "RISC OS 6",
   OS_AreaAbortable       = OS_AreaFlags: 0x10000 "RISC OS 6",
   OS_AreaDomain          = OS_AreaFlags: 0x20000 "RISC OS 6",
   OS_AreaInvisible       = OS_AreaFlags: 0x40000 "RISC OS 6",
   OS_AreaFixedPage       = OS_AreaFlags: 0x80000 "RISC OS 6";

TYPE
   OS_MemMapRequest =
      .Struct
      (  .Int: page_no,
         .Ref .Data: map,
         OS_AreaFlags: access
      ),
   OS_MemMapRequestList =
      .Struct
      (  OS_MemMapRequest: requests ...
      );

TYPE
   OS_PageBlock =
      .Struct
      (  .Int: page_no,
         .Ref .Data: log_addr,
         .Ref .Data: phys_addr
      );

SWI OS_ReadMemMapEntries =
   (  NUMBER 0x52 "Reads by page number the logical to physical memory
            mapping used by MEMC",
      ENTRY (R0 = .Ref OS_MemMapRequestList: request_list)
   );

SWI OS_SetMemMapEntries =
   (  NUMBER 0x53 "Writes the logical to physical memory mapping used by
            MEMC",
      ENTRY (R0 -> OS_MemMapRequestList: request_list)
   );

SWI OS_AddCallBack =
   (  NUMBER 0x54 "Adds a transient callback to the list",
      ENTRY
      (  R0 -> .Asm: call_back,
         R1 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_ReadDefaultHandler =
   (  NUMBER 0x55 "Gets the address of the default handler",
      ENTRY
      (  R0 = .Int: handler_type
      ),
      EXIT
      (  R1! -> .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer
   )  );

SWI OS_SetECFOrigin =
   (  NUMBER 0x56 "Sets the origin of the ECF patterns",
      ENTRY
      (  R0 = .Int: x,
         R1 = .Int: y
   )  );

SWI OS_Confirm =
   (  NUMBER 0x59 "Gets a yes or no answer",
      EXIT
      (  R0 = .Char: key,
         FLAGS!
   )  );

TYPE OS_ChangedBoxState = .Int;
CONST OS_DisableChangedBox = OS_ChangedBoxState: 0,
   OS_EnableChangedBox = OS_ChangedBoxState: 1,
   OS_ResetChangedBox = OS_ChangedBoxState: 2,
   OS_ReadChangedBox = OS_ChangedBoxState: -1;

SWI OS_ChangedBox =
   (  NUMBER 0x5A "Determines which area of the screen has changed",
      ENTRY
      (  R0 = OS_ChangedBoxState: state
      ),
      EXIT
      (  R0! = .Bool: enabled,
         R1 -> OS_ChangeBox: change_box
   )  );

SWI OS_CRC =
   (  NUMBER 0x5B "Calculates the cyclic redundancy check for a block of
            data",
      ENTRY
      (  R0 = .Int: crc_in,
         R1 -> .Data: block,
         R2 -> .Char: end,
         R3 = .Int: stride
      ),
      EXIT
      (  R0! = .Int: crc
   )  );

SWI OS_ReadDynamicArea =
   (  NUMBER 0x5C "Reads the space allocation of a dynamic area",
      ENTRY
      (  R0 = OS_DynamicAreaNo: area
      ),
      EXIT
      (  R0! = .Ref .Data: area_start,
         R1 = .Int: size,
         R2 = .Int: size_limit
   )  );

SWI OS_PrintChar =
   (  NUMBER 0x5D "Sends a character to the printer stream",
      ENTRY
      (  R0 = .Char: c
   )  );

SWI OS_ChangeRedirection =
   (  NUMBER 0x5E "Reads or writes OS_CLI input/output redirection
            handles",
      ENTRY
      (  R0 = OS_F: input,
         R1 = OS_F: output
      ),
      EXIT
      (  R0 = OS_F: old_input,
         R1 = OS_F: old_output
   )  );

SWI OS_RemoveCallBack =
   (  NUMBER 0x5F "Removes a transient callback from the list",
      ENTRY
      (  R0 -> .Asm: call_back,
         R1 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_FindMemMapEntries =
   (  NUMBER 0x60 "Reads by logical address the logical to physical memory
            mapping used by MEMC",
      ENTRY (R0 = .Ref OS_MemMapRequestList: request_list)
   );

TYPE OS_ColourFlags = .Bits;
CONST
   OS_ColourSetBG        = OS_ColourFlags: 0b10000,
   OS_ColourGivenPattern = OS_ColourFlags: 0b100000,
   OS_ColourSetText      = OS_ColourFlags: 0b1000000 "RISC O S 3.5+",
   OS_ColourRead         = OS_ColourFlags: 0b10000000 "RISC O S 3.5+";

SWI OS_SetColour =
   (  NUMBER 0x61 "Sets the current colour or colour pattern",
      ENTRY
      (  R0 = OS_ColourFlags: flags,
         R1 = OS_ColourNumber: colour_number
   )  ),
   OS_ReadColour = //RO3.5
   (  NUMBER 0x61 "Reads the current colour or colour pattern - RISC O S
3.5+",
      ENTRY
      (  R0 # %10000000,
         R0 | OS_ColourFlags: flags,
         R1 = .Ref OS_ECF: pattern
      ),
      EXIT
      (  R0 = OS_ColourFlags: flags_out,
         R1! = OS_ColourNumber: colour_number
   )  );

TYPE OS_PointerType = .Int;
CONST
   PointerV_TypeQuadrature   = OS_PointerType: 0,
   PointerV_TypeMicrosoft    = OS_PointerType: 1,
   PointerV_TypeMouseSystems = OS_PointerType: 2;

SWI
   OS_Pointer = //RO3.5
      (NUMBER 0x64 "Gets or sets the currently selected pointer device
      type - see individual reason codes", ABSENT),
   OSPointer_Get = (NUMBER 0x64, ENTRY (R0 # 0 "Gets the currently selected
         pointer device type - RISC O S 3.5+"), EXIT (R0! =
OS_PointerType: pointer_type)),
   OSPointer_Set = (NUMBER 0x64, ENTRY (R0 # 1 "Sets the currently selected
         pointer device type - RISC O S 3.5+", R1 = OS_PointerType:
pointer_type), EXIT (R0?));

TYPE
   PointerV_Record = .Struct (.Ref PointerV_Record: next, .Bits: flags,
         OS_PointerType: pointer_type, [30] .Char: name);

SWI PointerV = (NUMBER 0x34, ENTRY (R9 # &26 "Used to communicate between the
      kernel and a pointer device driver -
      see individual reason codes"), ABSENT),

   PointerV_Status =
   (  NUMBER 0x34,
      ENTRY
      (  R0 # 0 "Requests status of pointer device - RISC O S 3.5+",
         R1 = OS_PointerType: pointer_type,
         R9 # &26
      ),
      EXIT
      (  R2 = .Int: xmove,
         R3 = .Int: ymove
   )  ),

   PointerV_Enumerate =
   (  NUMBER 0x34,
      ENTRY
      (  R0 # 1 "Enumerates pointer device types - RISC O S 3.5+",
         R1 -> PointerV_Record: record,
         R9 # &26
      ),
      EXIT
      (  R1! -> PointerV_Record: record_out
   )  ),

   PointerV_Selected =
   (  NUMBER 0x34,
      ENTRY
      (  R0 # 2 "Pointer device type selected - RISC O S 3.5+",
         R1 = OS_PointerType: pointer_type,
         R9 # &26
   )  );

SWI
   OS_ScreenMode = //RO3.5
         (NUMBER 0x65 "Performs miscellaneous operations for screen mode
         handling -
      see individual reason codes", ABSENT),
   OSScreenMode_Select = (NUMBER 0x65, ENTRY (R0 # 0 "Selects a screen
mode - RISC O S 3.5+",
         R1 = OS_Mode: mode)),
   OSScreenMode_Current = (NUMBER 0x65, ENTRY (R0 # 1 "Returns the mode
         specifier for the current mode - RISC O S 3.5+"), EXIT (R1! =
OS_Mode: mode)),
   OSScreenMode_Enumerate = (NUMBER 0x65, ENTRY (R0 # 2 "Enumerates the
         available screen modes - RISC O S 3.5+", R2 = .Int: context,
         R6 = .Ref OS_ModeBlock: block, R7 = .Int: block_size),
         EXIT (R1! = .Bool: complete, R2 = .Int: context_out,
         R6 -> .Data: end, R7 = .Int: free));

SWI OS_DynamicArea = //RO3.5
      (NUMBER 0x66 "Performs operations on dynamic areas -
      see individual reason codes", ABSENT);

CONST
   OSDynamicArea_AllocateArea = .Int: -1,
   OSDynamicArea_AllocateBase = .Ref .Data: -1;

SWI OSDynamicArea_Create =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 0 "Creates a new dynamic area - RISC O S 3.5+",
         R1 = OS_DynamicAreaNo: area,
         R2 = .Int: size,
         R3 -> .Data: base_address,
         R4 = .Bits: flags,
         R5 = .Int: size_limit,
         R6 -> .Asm: handler,
         R7 = .Ref Void: workspace,
         R8 -> .String: description
      ),
      EXIT
      (  R1! = OS_DynamicAreaNo: area_out,
         R3 -> .Data: base_address_out,
         R5 = .Int: size_limit_out
      )
   ),
   OSDynamicArea_Delete =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 1 "Removes a previously created dynamic area - RISC O S
3.5+",
         R1 = OS_DynamicAreaNo: area
   )  ),
   OSDynamicArea_Read =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 2 "Returns information on a dynamic area - RISC O S 3.5+",
         R1 = OS_DynamicAreaNo: area
      ),
      EXIT
      (  R2 = .Int: size,
         R3 -> .Data: base_address,
         R4 = .Bits: flags,
         R5 = .Int: size_limit,
         R6 -> .Asm: handler,
         R7 = .Ref Void: workspace,
         R8 -> .String: description
   )  ),
   OSDynamicArea_Enumerate =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 3 "Enumerates dynamic areas - RISC O S 3.5+",
         R1 = .Int: context
      ),
      EXIT
      (  R1! = .Int: context_out
   )  ),
   OSDynamicArea_Renumber =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 4 "Renumbers dynamic areas - RISC O S 3.5+",
         R1 = OS_DynamicAreaNo: old_area,
         R2 = OS_DynamicAreaNo: new_area
   )  ),

   OSDynamicArea_FreeSpace =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 5 "Return total free space, allowing for shrinkable areas - RISC OS 4+",
         R1 = OS_DynamicAreaNo: exclude_area
      ),
      EXIT
      (  R2! = .Int: free_space
   )  ),

   OSDynamicArea_SetClamps =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 8 "Set clamps on maximum sizes for subsequently created dynamic areas - RISC OS 4+",
         R1 = .Int: unlimited_area_clamp,
         R2 = .Int: limited_area_clamp,
         R3 = .Int: sparse_area_clamp
      ),
      EXIT
      (  R1 = .Int: old_unlimited_area_clamp,
         R2 = .Int: old_limited_area_clamp,
         R3 = .Int: old_sparse_area_clamp
   )  ),

   OSDynamicArea_EnsureRegion =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 9 "Ensures that a region of a sparse area is mapped to valid memory - RISC OS 4+",
         R1 = OS_DynamicAreaNo: area,
         R2 -> .Data: base_address,
         R3 = .Int: size
   )  ),

   OSDynamicArea_ReleaseRegion =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 10 "Allows a region of a sparse area to be released as free memory - RISC OS 4+",
         R1 = OS_DynamicAreaNo: area,
         R2 -> .Data: base_address,
         R3 = .Int: size
   )  ),

   OSDynamicArea_LockArea =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 11 "Lock the dynamic area - RISC OS 6",
         R1 = OS_DynamicAreaNo: area,
         R2 = .Int: lock_code
   )  ),

   OSDynamicArea_UnlockArea =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 12 "Unlock the dynamic area",
         R1 = OS_DynamicAreaNo: area,
         R2 = .Int: lock_code
   )  ),

   OSDynamicArea_HeapDescribe =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 14 "Describe the space used by a dynamic area's heap - RISC OS Select",
         R1 = OS_DynamicAreaNo: area
      ),
      EXIT
      (  R2 = .Int: max,
         R3! = .Int: free
   )  ),

   OSDynamicArea_HeapAlloc =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 15 "Claim space from a dynamic area's heap - RISC OS Select",
         R1 = OS_DynamicAreaNo: area,
         R3 = .Int: size
      ),
      EXIT
      (  R2! = .Ref Void: blk
   )  ),

   OSDynamicArea_HeapFree =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 16 "Release space previously claimed from a dynamic area's heap - RISC OS Select",
         R1 = OS_DynamicAreaNo: area,
         R2 = .Ref Void: blk
   )  ),

   OSDynamicArea_HeapRealloc =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 17 "Resize a previously claimed block from a dynamic area's heap - RISC OS Select",
         R1 = OS_DynamicAreaNo: area,
         R2 = .Ref Void: blk,
         R3 = .Int: size_increase
      ),
      EXIT
      (  R2! = .Ref Void: blk_out
   )  ),

   OSDynamicArea_HeapReadSize =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 18 "Read the size of a block allocated from a dynamic area's heap - RISC OS Select",
         R1 = OS_DynamicAreaNo: area,
         R2 = .Ref Void: blk
      ),
      EXIT
      (  R3! = .Int: size
   )  ),

   OSDynamicArea_ChangeDomainState =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 19 "Change the access of Domain dynamic areas to aborting, or
                  to allow full access - RISC OS 6",
         R1 = OS_DynamicAreaNo: area,
         R2 = OSDynamicAreaDomain_State: state
      ),
      EXIT
      (  R2! = OSDynamicAreaDomain_State: old_state
   )  );

TYPE OSAbortTrap_Flags = .Bits;
CONST
   OSAbortTrap_Register   = OSAbortTrap_Flags: 0,
   OSAbortTrap_Deregister = OSAbortTrap_Flags: 1;

SWI OS_AbortTrap =
   (  NUMBER 0x67 "Register or deregister an AbortTrap handler - RISC OS 6",
      ENTRY
      (  R0 = OSAbortTrap_Flags: operation,
         R1 = .Int: low_address,
         R2 = .Int: high_address,
         R3 = .Asm: abort_handler,
         R4 = .Int: r12_abort_handler
   )  );

SWI OS_Memory =
   (  NUMBER 0x68 "Performs miscellaneous operations for memory
                   management - RISC OS 3.5+, see individual reason codes",
      ABSENT
   );

TYPE OSMemory_Flags = .Bits;
CONST
   OSMemory_GivenPageNo    = OSMemory_Flags: %100000000,
   OSMemory_GivenLogAddr   = OSMemory_Flags: %1000000000,
   OSMemory_GivenPhysAddr  = OSMemory_Flags: %10000000000,
   OSMemory_ReturnPageNo   = OSMemory_Flags: %100000000000,
   OSMemory_ReturnLogAddr  = OSMemory_Flags: %1000000000000,
   OSMemory_ReturnPhysAddr = OSMemory_Flags: %10000000000000,
   OSMemory_Cache          = OSMemory_Flags: %1100000000000000,
   OSMemory_CacheShift     = .Int: 14,
   OSMemory_CacheDisable   = OSMemory_Flags: 2,
   OSMemory_CacheEnable    = OSMemory_Flags: 3;

TYPE OSMemory_TypeFlags = .Bits;
CONST
   OSMemory_Type        = OSMemory_TypeFlags: %111100000000,
   OSMemory_TypeShift   = .Int: 8,
   OSMemory_TypeAbsent  = OSMemory_TypeFlags: 0,
   OSMemory_TypeDRAM    = OSMemory_TypeFlags: 1,
   OSMemory_TypeVRAM    = OSMemory_TypeFlags: 2,
   OSMemory_TypeROM     = OSMemory_TypeFlags: 3,
   OSMemory_TypeIO      = OSMemory_TypeFlags: 4,
   OSMemory_TypeSoftROM = OSMemory_TypeFlags: 5 "RISC OS 5+";

TYPE OSMemory_ControllerFlags = .Bits;
CONST
   OSMemory_ControllerNo                = OS_ControllerFlags: &F,
   OSMemory_ControllerNoShift           = .Int: 0,
   OSMemory_ControllerType              = OS_ControllerFlags: &FFFFFFF0,
   OSMemory_ControllerTypeShift         = .Int: 8,
   OSMemory_ControllerTypeEASI          = OS_ControllerFlags: 0,
   OSMemory_ControllerTypeEASISpace     = OS_ControllerFlags: 1,
   OSMemory_ControllerTypeVIDC1         = OS_ControllerFlags: 2,
   OSMemory_ControllerTypeVIDC20        = OS_ControllerFlags: 3,
   OSMemory_ControllerTypeSSpace        = OS_ControllerFlags: 4 "RISC OS 5",
   OSMemory_ControllerTypeExtensionROMs = OS_ControllerFlags: 5 "RISC OS 5+",
   OSMemory_ControllerTypePrimaryROM    = OS_ControllerFlags: 32 "RISC OS 6",
   OSMemory_ControllerTypeIOMD          = OS_ControllerFlags: 33 "RISC OS 6",
   OSMemory_ControllerTypeFDC37C665     = OS_ControllerFlags: 34 "RISC OS 6";

TYPE OSMemory_IOFlags = .Bits;
CONST
   OSMemory_IOBufferable      = OSMemory_IOFlags: 0x100,
   OSMemory_IOCacheable       = OSMemory_IOFlags: 0x200,
   OSMemory_IODoublyMapped    = OSMemory_IOFlags: 0x10000,
   OSMemory_IORestrictAccess  = OSMemory_IOFlags: 0x20000,
   OSMemory_IOAccess          = OSMemory_IOFlags: 0xF000000,
   OSMemory_IOAccessShift     = .Int: 24;

TYPE OSMemory_IOReferenceKey;

TYPE OSMemory_AreaFlags = .Bits;
CONST
   OSMemory_Area                        = OSMemory_AreaFlags: 0xFF00,
   OSMemory_AreaShift                   = .Int: 8,
   OSMemory_AreaCursorSystemSound       = OSMemory_AreaFlags: 1,
   OSMemory_AreaIRQStack                = OSMemory_AreaFlags: 2,
   OSMemory_AreaSVCStack                = OSMemory_AreaFlags: 3,
   OSMemory_AreaABTStack                = OSMemory_AreaFlags: 4,
   OSMemory_AreaUNDStack                = OSMemory_AreaFlags: 5,
   OSMemory_AreaSoftCAM                 = OSMemory_AreaFlags: 6,
   OSMemory_AreaLevelOnePageTables      = OSMemory_AreaFlags: 7,
   OSMemory_AreaLevelTwoPageTables      = OSMemory_AreaFlags: 8,
   OSMemory_AreaHALWorkspace            = OSMemory_AreaFlags: 9,
   OSMemory_AreaKernelBuffers           = OSMemory_AreaFlags: 10,
   OSMemory_AreaUncacheableHALWorkspace = OSMemory_AreaFlags: 11;

TYPE
   OSMemoryRecommendPage_Flags = .Bits;
CONST
   OSMemoryRecommendPageFlags_DMA = OSMemoryRecommendPage_Flags: 0x100;

TYPE
   OSMemoryCheckMemoryAccess_Flags = .Bits,
   OSMemoryCheckMemoryAccess_Bits = .Bits;
CONST
   OSMemoryCheckMemoryAccessBits_UserRFull = OSMemoryCheckMemoryAccess_Bits: 0x0001,
   OSMemoryCheckMemoryAccessBits_UserWFull = OSMemoryCheckMemoryAccess_Bits: 0x0002,
   OSMemoryCheckMemoryAccessBits_PrivRFull = OSMemoryCheckMemoryAccess_Bits: 0x0004,
   OSMemoryCheckMemoryAccessBits_PrivWFull = OSMemoryCheckMemoryAccess_Bits: 0x0008,
   OSMemoryCheckMemoryAccessBits_UserRPart = OSMemoryCheckMemoryAccess_Bits: 0x0010,
   OSMemoryCheckMemoryAccessBits_UserWPart = OSMemoryCheckMemoryAccess_Bits: 0x0020,
   OSMemoryCheckMemoryAccessBits_PrivRPart = OSMemoryCheckMemoryAccess_Bits: 0x0040,
   OSMemoryCheckMemoryAccessBits_PrivWFull = OSMemoryCheckMemoryAccess_Bits: 0x0080,
   OSMemoryCheckMemoryAccessBits_PhysFull  = OSMemoryCheckMemoryAccess_Bits: 0x0100,
   OSMemoryCheckMemoryAccessBits_AbortFull = OSMemoryCheckMemoryAccess_Bits: 0x0200,
   OSMemoryCheckMemoryAccessBits_PhysPart  = OSMemoryCheckMemoryAccess_Bits: 0x1000,
   OSMemoryCheckMemoryAccessBits_AbortPart = OSMemoryCheckMemoryAccess_Bits: 0x2000;

TYPE
   OSMemoryReadControllerBaseAddress_Flags = .Bits;

SWI
   OSMemory_PageOp =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 0 "General page block operations - RISC OS 3.5+",
         R0 | OSMemory_Flags: flags,
         R1 -> OS_PageBlock: page_block,
         R2 = .Int: page_count
   )  ),

   OSMemory_ReadArrangementTableSize =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 6 "Reads the size of the physical memory arrangement table
                 - RISC OS 3.5+ - deprecated in RISC OS 6"
      ),
      EXIT
      (  R1! = .Int: table_size,
         R2 = .Int: page_size
   )  ),

   OSMemory_ReadArrangementTable =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 7 "Read the physical memory arrangement table - RISC OS 3.5+
                 - deprecated in RISC OS 6",
         R1 = .Ref .Data: arrangement_table
   )  ),

   OSMemory_ReadSize =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 8 "Reads the amount of a specified type of memory available on the
                 computer - RISC OS 3.5+",
         R0 | OSMemory_TypeFlags: type
      ),
      EXIT
      (   R1 = .Int: page_count,
          R2 = .Int: page_size
   )  ),

   OSMemory_ReadController =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 9 "Reads controller presence and base address - RISC OS 3.5+",
         R1 = OSMemory_ControllerFlags: controller
      ),
      EXIT
      (  R1 = .Asm: controller_addr
   )  ),

   OSMemory_LockFreePool =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 10 "Lock the free pool in order to implement Wimp_ClaimFreeMemory
                  - no longer used / deprecated"
      ),
      ABSENT
   ),

   OSMemory_MapPCIMemory =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 11 "Map PCI memory within the Phoebe hardware - no longer used /
                  deprecated"
      ),
      ABSENT
   ),

   OSMemory_RecommendPage =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 12 "Recommends a base page for a currently available
      	       	  (not locked down) region of physically contiguous RAM - RISC OS 4+",
         R0 | OSMemoryRecommendPage_Flags: flags,
         R1 = .Int: size,
         R2 = .Int: alignment "between 12 and 30"
      ),
      EXIT
      (  R3! = .Int: page_number
   )  ),

   OSMemory_MapInPermanentIO =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 13 "Permanently map in a region of IO memory - RISC OS 5",
         R0 | OSMemory_IOFlags: flags,
         R1 = .Ref .Data: phys_addr,
         R2 = .Int: size
      ),
      EXIT
      (  R3! = .Ref .Data: log_addr
   )  ),

   OSMemory_MapInTemporaryIO =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 14 "Temporarily map in 1Mb of IO memory - RISC OS 5",
         R0 | OSMemory_IOFlags: flags,
         R1 = .Ref .Data: phys_addr
      ),
      EXIT
      (  R2! = .Ref .Data: log_addr,
         R3 = OSMemory_IOReferenceKey: key
   )  ),

   OSMemory_MapOutTemporaryIO =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 15 "Map out a region of temporary IO memory - RISC OS 5",
         R1 = OSMemory_IOReferenceKey: key
   )  ),

   OSMemory_GetAreaInfo =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 16 "Get information on a memory area - RISC OS 5",
         R0 | OSMemory_AreaFlags: type
      ),
      EXIT
      (  R1! = .Ref .Data: base,
         R2 = .Int: allocated,
         R3 = .Int: used
   )  ),

   OSMemory_CheckMemoryAccess =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 24 "Determine the accessibility of a range of memory - RISC OS 6",
         R0 | OSMemoryCheckMemoryAccess_Flags: flags,
         R1 = .Ref .Data: low,
         R2 = .Ref .Data: high
      ),
      EXIT
      (  R1! = OSMemoryCheckMemoryAccess_Bits: access_flags
   )  ),

   OSMemory_ReadControllerBaseAddress =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 25 "Checks for the presence of a given controller and returns
                  its physical address - RISC OS 6",
         R0 | OSMemoryReadControllerBaseAddress_Flags: flags,
         R1 = OSMemory_ControllerFlags: controller
      ),
      EXIT
      (  R1! = .Ref .Data: address
   )  );

SWI
   OS_ClaimProcessorVector =
   (  NUMBER 0x69 "Provides a means for a module to attach itself to one of
                   the processor's vectors - RISC OS 3.5+, see individual
                   reason codes",
      ABSENT
   ),

   OSClaimProcessorVector_Alloc =
   (  NUMBER 0x69,
      ENTRY
      (  R0 # %100000000 "Claims a processor vector - RISC OS 3.5+",
         R0 | .Bits: vector,
         R1 = .Asm: routine
      ),
      EXIT
      (  R1! = .Asm: old_routine
   )  ),

   OSClaimProcessorVector_Free =
   (  NUMBER 0x69,
      ENTRY
      (  R0 # 0 "Releases a processor vector - RISC OS 3.5+",
         R0 | .Bits: vector,
         R2 = .Asm: old_routine
      ),
      EXIT
      (  R1?
   )  );

SWI OS_Reset =
   (  NUMBER 0x6A "Performs a hard reset - RISC OS 3.5+"
   );

TYPE OS_MMUControlFlushRequestFlags = .Bits "For OS_MMUControl with reason code 1, RISC OS 3.7+";
CONST
   OS_MMUControlFlushRequestFlagSingleEntry = OS_MMUControlFlushRequestFlags: 0x20000000,
   OS_MMUControlFlushRequestFlagProcTLB     = OS_MMUControlFlushRequestFlags: 0x40000000,
   OS_MMUControlFlushRequestFlagProcCache   = OS_MMUControlFlushRequestFlags: 0x80000000;

SWI OS_MMUControl = //RO3.5
      (NUMBER 0x6B "Modifies the ARM MMU (prefer Cache_Control) - RISC O
S 3.5+",
      ENTRY (R0 # 0, R1 = .Bits: eor_mask, R2 = .Bits: and_mask),
      EXIT (R1! = .Bits: old_value, R2?));


TYPE OS_PlatformFeatureFlags = .Bits;
CONST
   OS_PlatformCodeNeedsSynchronisation 		= OS_PlatformFeatureFlags: %1,
   OS_PlatformNeedsPredisableFunction 		= OS_PlatformFeatureFlags: %10,
   OS_PlatformExceptionVectorModifyNeeds32bit 	= OS_PlatformFeatureFlags: %100,
   OS_PlatformPipelineLength2 			= OS_PlatformFeatureFlags: %1000,
   OS_PlatformFullEarlyDataAborts 		= OS_PlatformFeatureFlags: %10000,
   // Bit 5 is reserved
   // 20060801 TV fixed in accordance with http://www.iyonix.com/32bit/32bit.shtml
   OS_Platform32BitOS 				= OS_PlatformFeatureFlags: %1000000 	"RISC OS 5+",
   OS_Platform26BitModeNotAvailable 		= OS_PlatformFeatureFlags: %10000000 	"RISC OS 5+";

SWI
   OS_PlatformFeatures =
   (  NUMBER 0x6D "Reports various feaures of the platform - RISC OS 3.7+, see
                   individual reason codes",
      ABSENT
   ),

   OSPlatformFeatures_GetFeatures =
   (  NUMBER 0x6D,
      ENTRY
      (  R0 # 0 "Reports platform code features - RISC OS 3.7+"
      ),
      EXIT
      (  R0! = OS_PlatformFeatureFlags: flags,
         R1 = .Asm: predisable_fn
   )  ),

   OSPlatformFeatures_GetMMUFeatures =
   (  NUMBER 0x6D,
      ENTRY
      (  R0 # 1 "Reports MMU features - RISC OS 6"
      ),
      EXIT
      (  R0 = .Int: cache_enabled_state,
         R1 = .Int: cache_disabled_state,
         R2 = .Int: acceptable_flags_proc,
         R3 = .Int: required_flags_proc,
         R4 = .Int: acceptable_flags_os,
         R6 = .Int: required_flags_os
   )  );

TYPE OS_SynchroniseCodeFlags = .Bits;
CONST OS_GivenCodeRange = OS_SynchroniseCodeFlags: %1;
SWI
   OS_SynchroniseCodeAreas =
   (  NUMBER 0x6E "Informs the OS that code has been newly generated or modified
                   in memory - RISC OS 3.7+",
      ENTRY
      (  R0 = .Bits: flags,
         R1 = .Asm: start,
         R2 = .Asm: end
   )  );

SWI OS_CallASWI =
   (  NUMBER 0x6F "Calls a run-time determined SWI - RISC OS 3.7+, not APCS compliant",
      ABSENT
   );


SWI
   OS_ClaimOSSWI =
   (  NUMBER 0x77 "Claims or releases a software interrupt - see individual
                   reason codes",
      ABSENT
   ),

   OSClaimOSSWI_Claim =
   (  NUMBER 0x77,
      ENTRY
      (  R0 # 0 "Claims a software interrupt",
         R1 = .Int: swi,
         R2 = .Asm: routine,
         R3 = .Ref .Data: handle //should be int, like other handles
      ),
      EXIT
      (  R2 = .Asm: old_routine,
         R3 = .Ref .Data: old_handle
   )  ),

   OSClaimOSSWI_Release =
   (  NUMBER 0x77,
      ENTRY
      (  R0 # 1 "Releases a software interrupt",
         R1 = .Int: swi,
         R2 = .Asm: routine,
         R3 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI
   OS_TaskControl =
   (  NUMBER 0x78 "???", // FIXME: not sure what the common description is for this SWI.
      ABSENT
   ),

   OSTaskControl_ReadAddrStackResetCode =
   (  NUMBER 0x78,
      ENTRY
      (  R0 # 0 "Read address of stacks reset code"
      ),
      EXIT
      (  R0! = .Asm: routine
   )  );

SWI OS_ConvertStandardDateAndTime =
   (  NUMBER 0xC0 "Converts a 5-byte time into a string - prefer
            Territory_ConvertStandardDateAndTime",
      ENTRY
      (  R0 -> OS_DateAndTime: date_and_time,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertDateAndTime =
   (  NUMBER 0xC1 "Converts a 5-byte time into a string using a supplied
            format string - prefer Territory_ConvertDateAndTime",
      ENTRY
      (  R0 -> OS_DateAndTime: date_and_time,
         R1 = .Ref .String: buffer,
         R2 = .Int: size,
         R3 -> .String: format
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST
   OS_Hex1Limit = .Int: 1,
   OS_Hex2Limit = .Int: 2,
   OS_Hex4Limit = .Int: 4,
   OS_Hex6Limit = .Int: 6,
   OS_Hex8Limit = .Int: 8;

SWI OS_ConvertHex1 =
   (  NUMBER 0xD0 "Converts a number into a 1-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex2 =
   (  NUMBER 0xD1 "Converts a number into a 2-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex4 =
   (  NUMBER 0xD2 "Converts a number into a 4-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex6 =
   (  NUMBER 0xD3 "Converts a number into a 6-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex8 =
   (  NUMBER 0xD4 "Converts a number into an 8-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST
   OS_Cardinal1Limit = .Int: 3,
   OS_Cardinal2Limit = .Int: 5,
   OS_Cardinal3Limit = .Int: 8,
   OS_Cardinal4Limit = .Int: 10;

SWI OS_ConvertCardinal1 =
   (  NUMBER 0xD5 "Converts a 1-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertCardinal2 =
   (  NUMBER 0xD6 "Converts a 2-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertCardinal3 =
   (  NUMBER 0xD7 "Converts a 3-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertCardinal4 =
   (  NUMBER 0xD8 "Converts a 4-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST
   OS_Integer1Limit = .Int: 4,
   OS_Integer2Limit = .Int: 6,
   OS_Integer3Limit = .Int: 8,
   OS_Integer4Limit = .Int: 11;

SWI OS_ConvertInteger1 =
   (  NUMBER 0xD9 "Converts a 1-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertInteger2 =
   (  NUMBER 0xDA "Converts a 2-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertInteger3 =
   (  NUMBER 0xDB "Converts a 3-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertInteger4 =
   (  NUMBER 0xDC "Converts a 4-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST
   OS_Binary1Limit = .Int: 8,
   OS_Binary2Limit = .Int: 16,
   OS_Binary3Limit = .Int: 24,
   OS_Binary4Limit = .Int: 32;

SWI OS_ConvertBinary1 =
   (  NUMBER 0xDD "Converts a 1-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertBinary2 =
   (  NUMBER 0xDE "Converts a 2-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertBinary3 =
   (  NUMBER 0xDF "Converts a 3-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertBinary4 =
   (  NUMBER 0xE0 "Converts a 4-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST
   OS_SpacedCardinal1Limit = .Int: 3,
   OS_SpacedCardinal2Limit = .Int: 6,
   OS_SpacedCardinal3Limit = .Int: 10,
   OS_SpacedCardinal4Limit = .Int: 13;

SWI OS_ConvertSpacedCardinal1 =
   (  NUMBER 0xE1 "Converts a 1-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedCardinal2 =
   (  NUMBER 0xE2 "Converts a 2-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedCardinal3 =
   (  NUMBER 0xE3 "Converts a 3-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedCardinal4 =
   (  NUMBER 0xE4 "Converts a 4-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST
   OS_SpacedInteger1Limit = .Int: 4,
   OS_SpacedInteger2Limit = .Int: 7,
   OS_SpacedInteger3Limit = .Int: 10,
   OS_SpacedInteger4Limit = .Int: 14;

SWI OS_ConvertSpacedInteger1 =
   (  NUMBER 0xE5 "Converts a 1-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedInteger2 =
   (  NUMBER 0xE6 "Converts a 2-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedInteger3 =
   (  NUMBER 0xE7 "Converts a 3-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedInteger4 =
   (  NUMBER 0xE8 "Converts a 4-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST OS_FixedNetStationLimit = .Int: 7;

SWI OS_ConvertFixedNetStation =
   (  NUMBER 0xE9 "Converts from an Econet station/network number pair to
            a string of fixed length",
      ENTRY
      (  R0 -> OS_StationNumber: station_number,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST OS_NetStationLimit = .Int: 7;

SWI OS_ConvertNetStation =
   (  NUMBER 0xEA "Converts from an Econet station/network number pair to
            a string",
      ENTRY
      (  R0 -> OS_StationNumber: station_number,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST OS_FixedFileSizeLimit = .Int: 11;

SWI OS_ConvertFixedFileSize =
   (  NUMBER 0xEB "Converts an integer into a filesize string of fixed
            length",
      ENTRY
      (  R0 = .Int: file_size,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

CONST OS_FileSizeLimit = .Int: 11;

SWI OS_ConvertFileSize =
   (  NUMBER 0xEC "Converts an integer into a filesize string",
      ENTRY
      (  R0 = .Int: file_size,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1! -> .Char: end,
         R2?
   )  );

SWI OS_WriteI =
   (  NUMBER &100 "Writes an immediate byte - cannot be called via APCS",
      ABSENT
   );

SWI
   OS_Null =
   (  NUMBER 0x100 "VDU command for nul (no operation)"
   ),

   OS_CharToPrinter =
   (  NUMBER 0x101 "VDU command to send the next character to the printer only
                    - must be followed by 'char'"
   ),

   OS_PrinterOn =
   (  NUMBER 0x102 "VDU command to enable the printer stream - prefer PDriver"
   ),

   OS_PrinterOff =
   (  NUMBER 0x103 "VDU command to disable the printer stream - prefer PDriver"
   ),

   OS_SplitCursors =
   (  NUMBER 0x104 "VDU command to split the text and graphics cursors"
   ),

   OS_JoinCursors =
   (  NUMBER 0x105 "VDU command to join the text and graphics cursors"
   ),

   OS_VDUOn =
   (  NUMBER 0x106 "VDU command to enable screen output"
   ),

   OS_Bell =
   (  NUMBER 0x107 "VDU command to ring the bell"
   ),

   OS_Backspace =
   (  NUMBER 0x108 "VDU command to perform a backspace"
   ),

   OS_Tab =
   (  NUMBER 0x109 "VDU command to perform a horizontal tab"
   ),

   OS_LineFeed =
   (  NUMBER 0x10A "VDU command to perform a linefeed"
   ),

   OS_VerticalTab =
   (  NUMBER 0x10B "VDU command to perform a vertical tab"
   ),

   OS_ClS =
   (  NUMBER 0x10C "VDU command to clear the text window"
   ),

   OS_Return =
   (  NUMBER 0x10D "VDU command to perform a return"
   ),

   OS_PageModeOn =
   (  NUMBER 0x10E "VDU command to turn paged mode on"
   ),

   OS_PageModeOff =
   (  NUMBER 0x10F "VDU command to turn paged mode off"
   ),

   OS_ClG =
   (  NUMBER 0x110 "VDU command to clear the graphics window"
   ),

   OS_SetTextColour =
   (  NUMBER 0x111 "VDU command to set the text colour - must be followed by
                    'colour' - prefer OS_SetColour"
   ),

   OS_SetGCOL =
   (  NUMBER 0x112 "VDU command to set the graphics colour and action - must
                    be followed by 'action,' 'colour' - prefer OS_SetColour"
   ),

   OS_SetPalette =
   (  NUMBER 0x113 "VDU command to set the palette - must be followed by
                    'colour,' 'mode,' 'red,' 'green,' 'blue'"
   ),

   OS_ResetColours =
   (  NUMBER 0x114 "VDU command to restore default colours"
   ),

   OS_VDUOff =
   (  NUMBER 0x115 "VDU command to disable screen output"
   ),

   OS_SetMode =
   (  NUMBER 0x116 "VDU command to change display mode - must be followed by
                    'mode' - prefer OS_ScreenMode"
   ),

   OS_Misc =
   (  NUMBER 0x117 "Miscellaneous VDU commands - must be followed by 'command'
                    and 8 more arguments"
   ),

   OS_SetGraphicsWindow =
   (  NUMBER 0x118 "VDU command to define the graphics window - must be
                    followed by 'x0,' 'y0,' 'x1,' 'y1' (2 bytes each)"
   ),

   OS_PlotVDU =
   (  NUMBER 0x119 "General VDU plot commands - must be followed by 'plot_type'
                    and 'x,' 'y' (2 bytes each) - prefer OS_Plot"
   ),

   OS_ResetWindows =
   (  NUMBER 0x11A "VDU command to restore default windows"
   ),

   OS_Escape =
   (  NUMBER 0x11B "VDU command for escape (no operation)"
   ),

   OS_SetTextWindow =
   (  NUMBER 0x11C "VDU command to define the text window - must be followed
                    by 'x0,' 'y0,' 'x1,' 'y1'"
   ),

   OS_SetGraphicsOrigin =
   (  NUMBER 0x11D "VDU command to set the graphics origin - must be followed
                    by 'x,' 'y' (2 bytes each)"
   ),

   OS_HomeTextCursor =
   (  NUMBER 0x11E "VDU command to home the text cursor"
   ),

   OS_SetTextCursor =
   (  NUMBER 0x11F "VDU command to position the text cursor - must be followed
                    by 'x,' 'y'"
   ),

   OS_Space =
   (  NUMBER 0x120 "VDU command to perform a space"
   ),

   OS_Delete =
   (  NUMBER 0x17F "VDU command to perform a delete"
   );

SWI
   // Extends OS_CallAVector
   UserV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &00 "Calls UserV vector directly - reserved"
      ),
      ABSENT
   ),

   ErrorV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_Error: error,
         R9 # &01 "Calls ErrorV vector directly"
   )  ),

   IrqV =
   (  NUMBER 0x34,
      ENTRY (R9 # &2 "Called when an unknown IRQ is detected -
            obsolete"),
      ABSENT
   );

SWI
   UKVDU23V =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Int: n,
         R1 -> .Byte: queue,
         R9 # &17 "Called when an unrecognised VDU 23 command is issued"
   )  );

SWI
   VDUXV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Byte: b,
         R9 # &1B "Calls VDUXV vector directly and called when VDU output has been redirected"
   )  ),

   TickerV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &1C "Calls TickerV vector directly and called every centisecond"
   )  ),

   UpCallV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &1D "Calls UpCallV vector directly - reason codes as OS_UpCall"
      ),
      ABSENT
   ),

   ChangeEnvironmentV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_HandlerType: handler_type,
         R1 = .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer,
         R9 # &1E "Calls ChangeEnvironmentV vector directly"
      ),
      EXIT
      (  R1! = .Asm: old_handler,
         R2 = .Ref .Data: old_handle, //should be int, like other handles
         R3 = .Ref .Data: old_buffer
   )  ),

   PaletteV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &23 "Calls PaletteV vector directly and called when the palette
                   is to be read or written - see individual reason codes"
      ),
      ABSENT
   ),

   PaletteV_ReadEntry =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type,
         R4 # 1 "Calls PaletteV vector directly and reads the palette",
         R9 # &23
      ),
      EXIT
      (  R2 = OS_Colour: on,
         R3 = OS_Colour: off,
         R4! = .Bool: incomplete
   )  ),

   PaletteV_SetEntry =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type,
         R2 = OS_Colour: on,
         R3 = OS_Colour: off,
         R4 # 2 "Calls PaletteV vector directly and sets the palette",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetOn =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 3 "Calls PaletteV vector directly and sets the flash state to on",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetOff =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 4 "Calls PaletteV vector directly and sets the flash state to off",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_Default =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 5 "Calls PaletteV vector directly and sets the palette to the default",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_BlankScreen =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = PaletteV_ScreenState: state,
         R4 # 6 "Calls PaletteV vector directly and called to control screenblanking",
         R9 # &23
      ),
      EXIT
      (  R0 = PaletteV_ScreenState: state_out,
         R4! = .Bool: incomplete
   )  ),

   PaletteV_ReadEntries =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_ColourNumber: entry_list,
         R1 = .Bits: colour_type_and_entry_count,
         R2 = .Ref OS_Palette: on,
         R3 = .Ref OS_Palette: off,
         R4 # 7 "Calls PaletteV vector directly and called to read palette entries",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_WriteEntries =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_ColourNumber: entry_list,
         R1 = .Bits: colour_type_and_entry_count,
         R2 -> OS_Palette: palette,
         R4 # 8 "Calls PaletteV vector directly and called to write palette entries",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetGammaCorrections =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_CorrectionTable: red_table,
         R1 -> OS_CorrectionTable: green_table,
         R2 -> OS_CorrectionTable: blue_table,
         R4 # 9 "Calls PaletteV vector directly and called to set the gamma correction tables",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_InvertLCD =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Int: do_invert,
         R4 # 10 "Calls PaletteV vector directly and called to invert the LCD display",
         R9 # &23
      ),
//      EXIT
//      (  R4! = .Bool: incomplete
//      ),
      ABSENT
   ),

   PaletteV_DimScreen =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 11 "Calls PaletteV vector directly and called to control screen dimming",
         R9 # &23
      ),
//      EXIT
//      (  R4! = .Bool: incomplete
//      ),
      ABSENT
   ),

   PaletteV_DisableVideoHardware =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 12 "Power down the video hardware for the current display driver"
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_EnableVideoHardware =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 13 "Enable power the video hardware for the current display driver"
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  );

TYPE
   OS_ModeBlock =
   .Struct
   (  .Int: size,
      .Bits: flags,
      .Int: xres,
      .Int: yres,
      .Int: log2_bpp,
      .Int: frame_rate,
      .Char: name
      ...
   ),

   OS_ModeSelector =
   .Struct
   (  .Bits: flags,
      .Int: xres,
      .Int: yres,
      .Int: log2_bpp,
      .Int: frame_rate,
      .Struct
      (  OS_ModeVar: var,
         .Int: val
      ): modevars ...
   );


SWI
   // Extends OS_ServiceCall
   Service_ReleaseFIQ =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x0B "FIQ released"
   )  ),

   Service_ClaimFIQ =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x0C "FIQ claimed"
   )  ),

   Service_Reset =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x27 "Post-reset. Also, request to task modules and filing
                    system-specific desktop filers to set task_handle variable
                    to 0"
   )  ),

   Service_KeyHandler =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x44 "Keyboard handler changed",
         R2 = .Int: keyboard_id
   )  ),

   Service_ModeChange =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x46 "Mode changed"
   )  ),

   Service_ClaimFIQInBackground =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x47 "FIQ claimed in background"
   )  ),

   Service_MemoryMoved =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x4E "Memory moved"
   )  ),

   Service_PreModeChange =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x4D "Mode change",
         R2 = OS_Mode: mode
   )  ),

   Service_ModeExtension =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x50 "Allow soft modes",
         R2 = OS_Mode: mode,
         R3 = .Int: monitor_type,
         R4 = .Int: bandwidth "RISC OS 3.5+",
         R5 = .Int: vram_size "RISC OS 3.5+"
      ),
      EXIT
      (  R1! = .Bool: unclaimed,
         R3 -> .Int: vidc_list,
         R4 -> .Int: workspace_list
   )  ),

   Service_ModeTranslation =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x51 "Translate modes for unknown monitor types",
         R2 = OS_Mode: mode,
         R3 = .Int: monitor_type
   )  ),

   Service_ValidateAddress =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x6D "OS_ValidateAddress has been called with an unknown area"
   )  ),

   Service_MonitorLeadTranslation =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x76 "Translate monitor lead ID",
         R2 = .Int: lead_id
   )  ),

   Service_ModeChanging =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x89 "Mode change",
         R2 = OS_Mode: mode,
         R3 = .Int: monitor_type
   )  ),

   Service_EnumerateScreenModes =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x8D "Enumerates the available screen modes",
         R2 = .Int: context,
         R3 = .Int: monitor_type,
         R4 = .Int: bandwidth,
         R5 = .Int: vram_size,
         R6 = .Ref OS_ModeBlock: block,
         R7 = .Int: block_size
      ),
      EXIT
      (  R1! = .Bool: unclaimed,
         R2 = .Int: context_out,
         R6 -> .Data: end,
         R7 = .Int: free
   )  ),

   Service_PagesUnsafe =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x8E "Pages specified are about to be swapped for different
                    pages - RISC OS 3.5+",
         R2 -> OS_PageBlock: page_block,
         R3 = .Int: request_count
   )  ),

   Service_PagesSafe =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x8F "Pages specified have been swapped for different pages
                    - RISC OS 3.5+",
         R2 = .Int: request_count,
         R3 -> OS_PageBlock: old_page_block,
         R4 -> OS_PageBlock: new_page_block
   )  ),

   Service_DynamicAreaCreate =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x90 "Dynamic area has just been successfully created
                    - RISC OS 3.5+",
         R2 = .Int: area
   )  ),

   Service_DynamicAreaRemove =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x91 "Dynamic area is about to be removed - RISC OS 3.5+",
         R2 = .Int: area
   )  ),

   Service_DynamicAreaRenumber =
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x92 "Dynamic area is being renumbered - RISC OS 3.5+",
         R2 = .Int: area
   )  );

CONST //for Event_MouseTransition
   OS_TransitionMouseRight  = .Bits: 0b1,
   OS_TransitionMouseMiddle = .Bits: 0b10,
   OS_TransitionMouseLeft   = .Bits: 0b100;

CONST //for Event_KeyTransition
   OS_TransitionKeyEscape       = .Byte: &00,
   OS_TransitionKeyF1           = .Byte: &01,
   OS_TransitionKeyF2           = .Byte: &02,
   OS_TransitionKeyF3           = .Byte: &03,
   OS_TransitionKeyF4           = .Byte: &04,
   OS_TransitionKeyF5           = .Byte: &05,
   OS_TransitionKeyF6           = .Byte: &06,
   OS_TransitionKeyF7           = .Byte: &07,
   OS_TransitionKeyF8           = .Byte: &08,
   OS_TransitionKeyF9           = .Byte: &09,
   OS_TransitionKeyF10          = .Byte: &0A,
   OS_TransitionKeyF11          = .Byte: &0B,
   OS_TransitionKeyF12          = .Byte: &0C,
   OS_TransitionKeyPrint        = .Byte: &0D,
   OS_TransitionKeyScrollLock   = .Byte: &0E,
   OS_TransitionKeyBreak        = .Byte: &0F,
   OS_TransitionKeyGrave        = .Byte: &10,
   OS_TransitionKey1            = .Byte: &11,
   OS_TransitionKey2            = .Byte: &12,
   OS_TransitionKey3            = .Byte: &13,
   OS_TransitionKey4            = .Byte: &14,
   OS_TransitionKey5            = .Byte: &15,
   OS_TransitionKey6            = .Byte: &16,
   OS_TransitionKey7            = .Byte: &17,
   OS_TransitionKey8            = .Byte: &18,
   OS_TransitionKey9            = .Byte: &19,
   OS_TransitionKey0            = .Byte: &1A,
   OS_TransitionKeyHyphen       = .Byte: &1B,
   OS_TransitionKeyEquals       = .Byte: &1C,
   OS_TransitionKeyPound        = .Byte: &1D,
   OS_TransitionKeyBackspace    = .Byte: &1E,
   OS_TransitionKeyInsert       = .Byte: &1F,
   OS_TransitionKeyHome         = .Byte: &20,
   OS_TransitionKeyPageUp       = .Byte: &21,
   OS_TransitionKeyNumLock      = .Byte: &22,
   OS_TransitionKeyKeypadSlash  = .Byte: &23,
   OS_TransitionKeyKeypadStar   = .Byte: &24,
   OS_TransitionKeyKeypadHash   = .Byte: &25,
   OS_TransitionKeyTab          = .Byte: &26,
   OS_TransitionKeyQ            = .Byte: &27,
   OS_TransitionKeyW            = .Byte: &28,
   OS_TransitionKeyE            = .Byte: &29,
   OS_TransitionKeyR            = .Byte: &2A,
   OS_TransitionKeyT            = .Byte: &2B,
   OS_TransitionKeyY            = .Byte: &2C,
   OS_TransitionKeyU            = .Byte: &2D,
   OS_TransitionKeyI            = .Byte: &2E,
   OS_TransitionKeyO            = .Byte: &2F,
   OS_TransitionKeyP            = .Byte: &30,
   OS_TransitionKeySquareBra    = .Byte: &31,
   OS_TransitionKeySquareKet    = .Byte: &32,
   OS_TransitionKeyBackslash    = .Byte: &33,
   OS_TransitionKeyDelete       = .Byte: &34,
   OS_TransitionKeyCopy         = .Byte: &35,
   OS_TransitionKeyPageDown     = .Byte: &36,
   OS_TransitionKeyKeypad7      = .Byte: &37,
   OS_TransitionKeyKeypad8      = .Byte: &38,
   OS_TransitionKeyKeypad9      = .Byte: &39,
   OS_TransitionKeyKeypadMinus  = .Byte: &3A,
   OS_TransitionKeyLeftControl  = .Byte: &3B,
   OS_TransitionKeyA            = .Byte: &3C,
   OS_TransitionKeyS            = .Byte: &3D,
   OS_TransitionKeyD            = .Byte: &3E,
   OS_TransitionKeyF            = .Byte: &3F,
   OS_TransitionKeyG            = .Byte: &40,
   OS_TransitionKeyH            = .Byte: &41,
   OS_TransitionKeyJ            = .Byte: &42,
   OS_TransitionKeyK            = .Byte: &43,
   OS_TransitionKeyL            = .Byte: &44,
   OS_TransitionKeySemicolon    = .Byte: &45,
   OS_TransitionKeyAcute        = .Byte: &46,
   OS_TransitionKeyReturn       = .Byte: &47,
   OS_TransitionKeyKeypad4      = .Byte: &48,
   OS_TransitionKeyKeypad5      = .Byte: &49,
   OS_TransitionKeyKeypad6      = .Byte: &4A,
   OS_TransitionKeyKeypadPlus   = .Byte: &4B,
   OS_TransitionKeyLeftShift    = .Byte: &4C,
   //there is no key &4D
   OS_TransitionKeyZ            = .Byte: &4E,
   OS_TransitionKeyX            = .Byte: &4F,
   OS_TransitionKeyC            = .Byte: &50,
   OS_TransitionKeyV            = .Byte: &51,
   OS_TransitionKeyB            = .Byte: &52,
   OS_TransitionKeyN            = .Byte: &53,
   OS_TransitionKeyM            = .Byte: &54,
   OS_TransitionKeyComma        = .Byte: &55,
   OS_TransitionKeyPoint        = .Byte: &56,
   OS_TransitionKeySlash        = .Byte: &57,
   OS_TransitionKeyRightShift   = .Byte: &58,
   OS_TransitionKeyUp           = .Byte: &59,
   OS_TransitionKeyKeypad1      = .Byte: &5A,
   OS_TransitionKeyKeypad2      = .Byte: &5B,
   OS_TransitionKeyKeypad3      = .Byte: &5C,
   OS_TransitionKeyCapsLock     = .Byte: &5D,
   OS_TransitionKeyLeftAlt      = .Byte: &5E,
   OS_TransitionKeySpace        = .Byte: &5F,
   OS_TransitionKeyRightAlt     = .Byte: &60,
   OS_TransitionKeyRightControl = .Byte: &61,
   OS_TransitionKeyLeft         = .Byte: &62,
   OS_TransitionKeyDown         = .Byte: &63,
   OS_TransitionKeyRight        = .Byte: &64,
   OS_TransitionKeyKeypad0      = .Byte: &65,
   OS_TransitionKeyKeypadPoint  = .Byte: &66,
   OS_TransitionKeyEnter        = .Byte: &67;

CONST
   OS_TransitionUp   = .Int: 0,
   OS_TransitionDown = .Int: 1;

SWI
   Event_CharInput =
   (  NUMBER &22,
      ENTRY
      (  R0 # 2 "Character input",
         R1 = .Int: buffer,
         R2 = .Byte: b
   )  ),

   Event_VSync =
   (  NUMBER &22,
      ENTRY
      (  R0 # 4 "Vertical sync"
   )  ),

   Event_IntervalTimer =
   (  NUMBER &22,
      ENTRY
      (  R0 # 5 "Interval timer"
   )  ),

   Event_Escape =
   (  NUMBER &22,
      ENTRY
      (  R0 # 6 "Escape"
   )  ),

   Event_User =
   (  NUMBER &22,
      ENTRY
      (  R0 # 9 "User event - reserved"
      ),
      ABSENT
   ),

   Event_MouseTransition =
   (  NUMBER &22,
      ENTRY
      (  R0 # 10 "Mouse button up/down",
         R1 = .Int: x,
         R2 = .Int: y,
         R3 = .Bits: state,
         R4 = OS_T: t
      )
   ),

   Event_KeyTransition =
   (  NUMBER &22,
      ENTRY
      (  R0 # 11 "Key up/down",
         R1 = .Bool: down,
         R2 = .Int: key,
         R3 = .Int: keyboard_id
   )  ),

   Event_PointerScroll =
   (  NUMBER &22,
      ENTRY
      (  R0 # 21,
         R1 # 4 "Pointer scroll - RISC OS 4.32+",
         R2 = .Int: xmove,
         R3 = .int: ymove
   )  );

SWI
   // Extends OS_UpCall
   UpCall_MoveMemoryRequest =
   (  NUMBER 0x33,
      ENTRY
      (  R0 # 257 "Informs your program that RISC OS would like to move
               memory",
         R1 = .Int: size_change
      ),
      EXIT
      (  R0! = .Bool: not_moved
   )  )
